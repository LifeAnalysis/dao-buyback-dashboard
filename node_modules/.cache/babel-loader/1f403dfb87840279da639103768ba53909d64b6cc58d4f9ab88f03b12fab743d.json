{"ast":null,"code":"var _DatabaseService;\nimport Database from 'better-sqlite3';\nimport path from 'path';\nexport class DatabaseService {\n  constructor() {\n    this.db = void 0;\n    // In a production environment, this would be configurable\n    const dbPath = path.join(process.cwd(), 'data', 'buybacks.db');\n    this.db = new Database(dbPath);\n    this.initializeTables();\n  }\n  static getInstance() {\n    if (!DatabaseService.instance) {\n      DatabaseService.instance = new DatabaseService();\n    }\n    return DatabaseService.instance;\n  }\n  initializeTables() {\n    // Create buyback records table\n    this.db.exec(`\n      CREATE TABLE IF NOT EXISTS buyback_records (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        protocol TEXT NOT NULL,\n        token TEXT NOT NULL,\n        timestamp TEXT NOT NULL,\n        total_repurchased REAL NOT NULL,\n        total_value_usd REAL NOT NULL,\n        circulating_supply_percent REAL NOT NULL,\n        estimated_annual_buyback REAL NOT NULL,\n        fee_allocation_percent REAL NOT NULL,\n        price_per_token REAL NOT NULL,\n        trading_volume_24h REAL,\n        fee_generation_24h REAL,\n        created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n      )\n    `);\n\n    // Create historical chart data table\n    this.db.exec(`\n      CREATE TABLE IF NOT EXISTS historical_charts (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        protocol TEXT NOT NULL,\n        timestamp TEXT NOT NULL,\n        value_usd REAL NOT NULL,\n        tokens_amount REAL NOT NULL,\n        cumulative_value REAL NOT NULL,\n        cumulative_tokens REAL NOT NULL,\n        created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n      )\n    `);\n\n    // Create index for better performance\n    this.db.exec(`\n      CREATE INDEX IF NOT EXISTS idx_buyback_protocol_timestamp \n      ON buyback_records(protocol, timestamp)\n    `);\n    this.db.exec(`\n      CREATE INDEX IF NOT EXISTS idx_historical_protocol_timestamp \n      ON historical_charts(protocol, timestamp)\n    `);\n  }\n\n  // Insert buyback record\n  insertBuybackRecord(record) {\n    const stmt = this.db.prepare(`\n      INSERT INTO buyback_records (\n        protocol, token, timestamp, total_repurchased, total_value_usd,\n        circulating_supply_percent, estimated_annual_buyback, fee_allocation_percent,\n        price_per_token, trading_volume_24h, fee_generation_24h\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n    `);\n    const result = stmt.run(record.protocol, record.token, record.timestamp, record.total_repurchased, record.total_value_usd, record.circulating_supply_percent, record.estimated_annual_buyback, record.fee_allocation_percent, record.price_per_token, record.trading_volume_24h || null, record.fee_generation_24h || null);\n    return result.lastInsertRowid;\n  }\n\n  // Insert historical chart data\n  insertHistoricalData(data) {\n    const stmt = this.db.prepare(`\n      INSERT INTO historical_charts (\n        protocol, timestamp, value_usd, tokens_amount, cumulative_value, cumulative_tokens\n      ) VALUES (?, ?, ?, ?, ?, ?)\n    `);\n    const result = stmt.run(data.protocol, data.timestamp, data.value_usd, data.tokens_amount, data.cumulative_value, data.cumulative_tokens);\n    return result.lastInsertRowid;\n  }\n\n  // Get latest buyback data for all protocols\n  getLatestBuybackData() {\n    const stmt = this.db.prepare(`\n      SELECT * FROM buyback_records \n      WHERE (protocol, timestamp) IN (\n        SELECT protocol, MAX(timestamp) \n        FROM buyback_records \n        GROUP BY protocol\n      )\n      ORDER BY protocol\n    `);\n    return stmt.all();\n  }\n\n  // Get historical data for charts\n  getHistoricalData(protocol, days = 30) {\n    const cutoffDate = new Date();\n    cutoffDate.setDate(cutoffDate.getDate() - days);\n    const cutoffTimestamp = cutoffDate.toISOString();\n    let stmt;\n    if (protocol) {\n      stmt = this.db.prepare(`\n        SELECT * FROM historical_charts \n        WHERE protocol = ? AND timestamp >= ? \n        ORDER BY timestamp ASC\n      `);\n      return stmt.all(protocol, cutoffTimestamp);\n    } else {\n      stmt = this.db.prepare(`\n        SELECT * FROM historical_charts \n        WHERE timestamp >= ? \n        ORDER BY protocol, timestamp ASC\n      `);\n      return stmt.all(cutoffTimestamp);\n    }\n  }\n\n  // Get buyback trends\n  getBuybackTrends(protocol, days = 30) {\n    const cutoffDate = new Date();\n    cutoffDate.setDate(cutoffDate.getDate() - days);\n    const cutoffTimestamp = cutoffDate.toISOString();\n    const stmt = this.db.prepare(`\n      SELECT \n        timestamp,\n        total_value_usd,\n        total_repurchased,\n        price_per_token,\n        trading_volume_24h\n      FROM buyback_records \n      WHERE protocol = ? AND timestamp >= ? \n      ORDER BY timestamp ASC\n    `);\n    return stmt.all(protocol, cutoffTimestamp);\n  }\n\n  // Get performance metrics\n  getPerformanceMetrics() {\n    const stmt = this.db.prepare(`\n      SELECT \n        protocol,\n        COUNT(*) as data_points,\n        AVG(total_value_usd) as avg_value_usd,\n        MAX(total_value_usd) as max_value_usd,\n        MIN(total_value_usd) as min_value_usd,\n        AVG(circulating_supply_percent) as avg_supply_reduction\n      FROM buyback_records \n      GROUP BY protocol\n    `);\n    return stmt.all();\n  }\n\n  // Clean old data (keep last 90 days)\n  cleanOldData() {\n    const cutoffDate = new Date();\n    cutoffDate.setDate(cutoffDate.getDate() - 90);\n    const cutoffTimestamp = cutoffDate.toISOString();\n    const stmt = this.db.prepare(`\n      DELETE FROM buyback_records \n      WHERE timestamp < ?\n    `);\n    const result = stmt.run(cutoffTimestamp);\n    return result.changes;\n  }\n\n  // Close database connection\n  close() {\n    this.db.close();\n  }\n}\n_DatabaseService = DatabaseService;\nDatabaseService.instance = void 0;","map":{"version":3,"names":["Database","path","DatabaseService","constructor","db","dbPath","join","process","cwd","initializeTables","getInstance","instance","exec","insertBuybackRecord","record","stmt","prepare","result","run","protocol","token","timestamp","total_repurchased","total_value_usd","circulating_supply_percent","estimated_annual_buyback","fee_allocation_percent","price_per_token","trading_volume_24h","fee_generation_24h","lastInsertRowid","insertHistoricalData","data","value_usd","tokens_amount","cumulative_value","cumulative_tokens","getLatestBuybackData","all","getHistoricalData","days","cutoffDate","Date","setDate","getDate","cutoffTimestamp","toISOString","getBuybackTrends","getPerformanceMetrics","cleanOldData","changes","close","_DatabaseService"],"sources":["/Users/gherardolattanzi/treasury/src/database/db.ts"],"sourcesContent":["import Database from 'better-sqlite3';\nimport path from 'path';\n\nexport interface BuybackRecord {\n  id?: number;\n  protocol: string;\n  token: string;\n  timestamp: string;\n  total_repurchased: number;\n  total_value_usd: number;\n  circulating_supply_percent: number;\n  estimated_annual_buyback: number;\n  fee_allocation_percent: number;\n  price_per_token: number;\n  trading_volume_24h?: number;\n  fee_generation_24h?: number;\n}\n\nexport interface HistoricalChart {\n  id?: number;\n  protocol: string;\n  timestamp: string;\n  value_usd: number;\n  tokens_amount: number;\n  cumulative_value: number;\n  cumulative_tokens: number;\n}\n\nexport class DatabaseService {\n  private static instance: DatabaseService;\n  private db: Database.Database;\n\n  constructor() {\n    // In a production environment, this would be configurable\n    const dbPath = path.join(process.cwd(), 'data', 'buybacks.db');\n    this.db = new Database(dbPath);\n    this.initializeTables();\n  }\n\n  public static getInstance(): DatabaseService {\n    if (!DatabaseService.instance) {\n      DatabaseService.instance = new DatabaseService();\n    }\n    return DatabaseService.instance;\n  }\n\n  private initializeTables(): void {\n    // Create buyback records table\n    this.db.exec(`\n      CREATE TABLE IF NOT EXISTS buyback_records (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        protocol TEXT NOT NULL,\n        token TEXT NOT NULL,\n        timestamp TEXT NOT NULL,\n        total_repurchased REAL NOT NULL,\n        total_value_usd REAL NOT NULL,\n        circulating_supply_percent REAL NOT NULL,\n        estimated_annual_buyback REAL NOT NULL,\n        fee_allocation_percent REAL NOT NULL,\n        price_per_token REAL NOT NULL,\n        trading_volume_24h REAL,\n        fee_generation_24h REAL,\n        created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n      )\n    `);\n\n    // Create historical chart data table\n    this.db.exec(`\n      CREATE TABLE IF NOT EXISTS historical_charts (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        protocol TEXT NOT NULL,\n        timestamp TEXT NOT NULL,\n        value_usd REAL NOT NULL,\n        tokens_amount REAL NOT NULL,\n        cumulative_value REAL NOT NULL,\n        cumulative_tokens REAL NOT NULL,\n        created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n      )\n    `);\n\n    // Create index for better performance\n    this.db.exec(`\n      CREATE INDEX IF NOT EXISTS idx_buyback_protocol_timestamp \n      ON buyback_records(protocol, timestamp)\n    `);\n\n    this.db.exec(`\n      CREATE INDEX IF NOT EXISTS idx_historical_protocol_timestamp \n      ON historical_charts(protocol, timestamp)\n    `);\n  }\n\n  // Insert buyback record\n  insertBuybackRecord(record: BuybackRecord): number {\n    const stmt = this.db.prepare(`\n      INSERT INTO buyback_records (\n        protocol, token, timestamp, total_repurchased, total_value_usd,\n        circulating_supply_percent, estimated_annual_buyback, fee_allocation_percent,\n        price_per_token, trading_volume_24h, fee_generation_24h\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n    `);\n\n    const result = stmt.run(\n      record.protocol,\n      record.token,\n      record.timestamp,\n      record.total_repurchased,\n      record.total_value_usd,\n      record.circulating_supply_percent,\n      record.estimated_annual_buyback,\n      record.fee_allocation_percent,\n      record.price_per_token,\n      record.trading_volume_24h || null,\n      record.fee_generation_24h || null\n    );\n\n    return result.lastInsertRowid as number;\n  }\n\n  // Insert historical chart data\n  insertHistoricalData(data: HistoricalChart): number {\n    const stmt = this.db.prepare(`\n      INSERT INTO historical_charts (\n        protocol, timestamp, value_usd, tokens_amount, cumulative_value, cumulative_tokens\n      ) VALUES (?, ?, ?, ?, ?, ?)\n    `);\n\n    const result = stmt.run(\n      data.protocol,\n      data.timestamp,\n      data.value_usd,\n      data.tokens_amount,\n      data.cumulative_value,\n      data.cumulative_tokens\n    );\n\n    return result.lastInsertRowid as number;\n  }\n\n  // Get latest buyback data for all protocols\n  getLatestBuybackData(): BuybackRecord[] {\n    const stmt = this.db.prepare(`\n      SELECT * FROM buyback_records \n      WHERE (protocol, timestamp) IN (\n        SELECT protocol, MAX(timestamp) \n        FROM buyback_records \n        GROUP BY protocol\n      )\n      ORDER BY protocol\n    `);\n\n    return stmt.all() as BuybackRecord[];\n  }\n\n  // Get historical data for charts\n  getHistoricalData(protocol?: string, days: number = 30): HistoricalChart[] {\n    const cutoffDate = new Date();\n    cutoffDate.setDate(cutoffDate.getDate() - days);\n    const cutoffTimestamp = cutoffDate.toISOString();\n\n    let stmt;\n    if (protocol) {\n      stmt = this.db.prepare(`\n        SELECT * FROM historical_charts \n        WHERE protocol = ? AND timestamp >= ? \n        ORDER BY timestamp ASC\n      `);\n      return stmt.all(protocol, cutoffTimestamp) as HistoricalChart[];\n    } else {\n      stmt = this.db.prepare(`\n        SELECT * FROM historical_charts \n        WHERE timestamp >= ? \n        ORDER BY protocol, timestamp ASC\n      `);\n      return stmt.all(cutoffTimestamp) as HistoricalChart[];\n    }\n  }\n\n  // Get buyback trends\n  getBuybackTrends(protocol: string, days: number = 30): any[] {\n    const cutoffDate = new Date();\n    cutoffDate.setDate(cutoffDate.getDate() - days);\n    const cutoffTimestamp = cutoffDate.toISOString();\n\n    const stmt = this.db.prepare(`\n      SELECT \n        timestamp,\n        total_value_usd,\n        total_repurchased,\n        price_per_token,\n        trading_volume_24h\n      FROM buyback_records \n      WHERE protocol = ? AND timestamp >= ? \n      ORDER BY timestamp ASC\n    `);\n\n    return stmt.all(protocol, cutoffTimestamp);\n  }\n\n  // Get performance metrics\n  getPerformanceMetrics(): any {\n    const stmt = this.db.prepare(`\n      SELECT \n        protocol,\n        COUNT(*) as data_points,\n        AVG(total_value_usd) as avg_value_usd,\n        MAX(total_value_usd) as max_value_usd,\n        MIN(total_value_usd) as min_value_usd,\n        AVG(circulating_supply_percent) as avg_supply_reduction\n      FROM buyback_records \n      GROUP BY protocol\n    `);\n\n    return stmt.all();\n  }\n\n  // Clean old data (keep last 90 days)\n  cleanOldData(): number {\n    const cutoffDate = new Date();\n    cutoffDate.setDate(cutoffDate.getDate() - 90);\n    const cutoffTimestamp = cutoffDate.toISOString();\n\n    const stmt = this.db.prepare(`\n      DELETE FROM buyback_records \n      WHERE timestamp < ?\n    `);\n\n    const result = stmt.run(cutoffTimestamp);\n    return result.changes;\n  }\n\n  // Close database connection\n  close(): void {\n    this.db.close();\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}