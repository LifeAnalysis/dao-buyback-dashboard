{"ast":null,"code":"var _DatabaseService;\n// Browser-compatible database service using localStorage\n// This replaces better-sqlite3 for client-side storage\n\nexport class DatabaseService {\n  static getInstance() {\n    if (!DatabaseService.instance) {\n      DatabaseService.instance = new DatabaseService();\n    }\n    return DatabaseService.instance;\n  }\n  constructor() {\n    this.BUYBACK_KEY = 'buyback_records';\n    this.HISTORICAL_KEY = 'historical_charts';\n    this.initializeWithSampleData();\n  }\n  initializeWithSampleData() {\n    // Check if data already exists\n    const existingBuyback = localStorage.getItem(this.BUYBACK_KEY);\n    const existingHistorical = localStorage.getItem(this.HISTORICAL_KEY);\n    if (!existingBuyback || !existingHistorical) {\n      this.generateSampleData();\n    }\n  }\n  generateSampleData() {\n    const protocols = [{\n      name: 'Hyperliquid',\n      token: 'HYPE',\n      basePrice: 19.3,\n      baseVolume: 1200000000\n    }, {\n      name: 'Jupiter',\n      token: 'JUP',\n      basePrice: 0.6,\n      baseVolume: 850000000\n    }, {\n      name: 'Aave',\n      token: 'AAVE',\n      basePrice: 192,\n      baseVolume: 45000000\n    }, {\n      name: 'Jito',\n      token: 'JTO',\n      basePrice: 5.0,\n      baseVolume: 320000000\n    }, {\n      name: 'Pump.fun',\n      token: 'PUMP',\n      basePrice: 0.165,\n      baseVolume: 180000000\n    }];\n    const buybackRecords = [];\n    const historicalCharts = [];\n    const now = new Date();\n    let cumulativeData = {\n      'Hyperliquid': {\n        value: 350000000,\n        tokens: 18000000\n      },\n      'Jupiter': {\n        value: 24000000,\n        tokens: 42000000\n      },\n      'Aave': {\n        value: 20000000,\n        tokens: 115000\n      },\n      'Jito': {\n        value: 35000000,\n        tokens: 7500000\n      },\n      'Pump.fun': {\n        value: 20000000,\n        tokens: 125000000\n      }\n    };\n    for (let i = 30; i >= 0; i--) {\n      const date = new Date(now);\n      date.setDate(date.getDate() - i);\n      const timestamp = date.toISOString();\n      protocols.forEach(protocol => {\n        // Generate realistic variance\n        const priceVariance = 0.9 + Math.random() * 0.2;\n        const volumeVariance = 0.8 + Math.random() * 0.4;\n        const price = protocol.basePrice * priceVariance;\n        const volume = protocol.baseVolume * volumeVariance;\n\n        // Calculate buyback amounts\n        let feePercent, dailyBuybackUSD, dailyTokens;\n        if (protocol.name === 'Hyperliquid') {\n          feePercent = 97;\n          dailyBuybackUSD = volume * 0.0002 * 0.97;\n          dailyTokens = dailyBuybackUSD / price;\n        } else if (protocol.name === 'Jupiter') {\n          feePercent = 50;\n          dailyBuybackUSD = volume * 0.0001 * 0.5;\n          dailyTokens = dailyBuybackUSD / price;\n        } else {\n          // Aave\n          feePercent = 100;\n          dailyBuybackUSD = Math.min(1000000 / 7, volume * 0.0004);\n          dailyTokens = dailyBuybackUSD / price;\n        }\n\n        // Update cumulative data\n        cumulativeData[protocol.name].value += dailyBuybackUSD;\n        cumulativeData[protocol.name].tokens += dailyTokens;\n\n        // Add buyback record\n        buybackRecords.push({\n          id: buybackRecords.length + 1,\n          protocol: protocol.name,\n          token: protocol.token,\n          timestamp,\n          total_repurchased: cumulativeData[protocol.name].tokens,\n          total_value_usd: cumulativeData[protocol.name].value,\n          circulating_supply_percent: protocol.name === 'Hyperliquid' ? 6.2 : protocol.name === 'Jupiter' ? 3.6 : 0.8,\n          estimated_annual_buyback: protocol.name === 'Hyperliquid' ? 600000000 : protocol.name === 'Jupiter' ? 250000000 : 52000000,\n          fee_allocation_percent: feePercent,\n          price_per_token: price,\n          trading_volume_24h: volume,\n          fee_generation_24h: volume * 0.0002\n        });\n\n        // Add historical chart data\n        historicalCharts.push({\n          id: historicalCharts.length + 1,\n          protocol: protocol.name,\n          timestamp,\n          value_usd: dailyBuybackUSD,\n          tokens_amount: dailyTokens,\n          cumulative_value: cumulativeData[protocol.name].value,\n          cumulative_tokens: cumulativeData[protocol.name].tokens\n        });\n      });\n    }\n    localStorage.setItem(this.BUYBACK_KEY, JSON.stringify(buybackRecords));\n    localStorage.setItem(this.HISTORICAL_KEY, JSON.stringify(historicalCharts));\n  }\n\n  // Insert buyback record\n  insertBuybackRecord(record) {\n    const records = this.getBuybackRecords();\n    const newId = Math.max(...records.map(r => r.id || 0), 0) + 1;\n    record.id = newId;\n    records.push(record);\n    localStorage.setItem(this.BUYBACK_KEY, JSON.stringify(records));\n    return newId;\n  }\n\n  // Insert historical chart data\n  insertHistoricalData(data) {\n    const records = this.getHistoricalRecords();\n    const newId = Math.max(...records.map(r => r.id || 0), 0) + 1;\n    data.id = newId;\n    records.push(data);\n    localStorage.setItem(this.HISTORICAL_KEY, JSON.stringify(records));\n    return newId;\n  }\n  getBuybackRecords() {\n    const data = localStorage.getItem(this.BUYBACK_KEY);\n    return data ? JSON.parse(data) : [];\n  }\n  getHistoricalRecords() {\n    const data = localStorage.getItem(this.HISTORICAL_KEY);\n    return data ? JSON.parse(data) : [];\n  }\n\n  // Get latest buyback data for all protocols\n  getLatestBuybackData() {\n    const records = this.getBuybackRecords();\n    const latestByProtocol = {};\n    records.forEach(record => {\n      if (!latestByProtocol[record.protocol] || new Date(record.timestamp) > new Date(latestByProtocol[record.protocol].timestamp)) {\n        latestByProtocol[record.protocol] = record;\n      }\n    });\n    return Object.values(latestByProtocol);\n  }\n\n  // Get historical data for charts\n  getHistoricalData(protocol, days = 30) {\n    const records = this.getHistoricalRecords();\n    const cutoffDate = new Date();\n    cutoffDate.setDate(cutoffDate.getDate() - days);\n    return records.filter(record => {\n      const recordDate = new Date(record.timestamp);\n      const matchesProtocol = !protocol || record.protocol === protocol;\n      const withinTimeframe = recordDate >= cutoffDate;\n      return matchesProtocol && withinTimeframe;\n    }).sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());\n  }\n\n  // Get buyback trends\n  getBuybackTrends(protocol, days = 30) {\n    const records = this.getBuybackRecords();\n    const cutoffDate = new Date();\n    cutoffDate.setDate(cutoffDate.getDate() - days);\n    return records.filter(record => {\n      const recordDate = new Date(record.timestamp);\n      return record.protocol === protocol && recordDate >= cutoffDate;\n    }).map(record => ({\n      timestamp: record.timestamp,\n      total_value_usd: record.total_value_usd,\n      total_repurchased: record.total_repurchased,\n      price_per_token: record.price_per_token,\n      trading_volume_24h: record.trading_volume_24h\n    })).sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());\n  }\n\n  // Get performance metrics\n  getPerformanceMetrics() {\n    const records = this.getBuybackRecords();\n    const metricsByProtocol = {};\n    records.forEach(record => {\n      if (!metricsByProtocol[record.protocol]) {\n        metricsByProtocol[record.protocol] = {\n          protocol: record.protocol,\n          data_points: 0,\n          total_value: 0,\n          values: [],\n          supply_reductions: []\n        };\n      }\n      const metrics = metricsByProtocol[record.protocol];\n      metrics.data_points++;\n      metrics.total_value += record.total_value_usd;\n      metrics.values.push(record.total_value_usd);\n      metrics.supply_reductions.push(record.circulating_supply_percent);\n    });\n    return Object.values(metricsByProtocol).map(metrics => ({\n      protocol: metrics.protocol,\n      data_points: metrics.data_points,\n      avg_value_usd: metrics.total_value / metrics.data_points,\n      max_value_usd: Math.max(...metrics.values),\n      min_value_usd: Math.min(...metrics.values),\n      avg_supply_reduction: metrics.supply_reductions.reduce((a, b) => a + b, 0) / metrics.supply_reductions.length\n    }));\n  }\n\n  // Clean old data (keep last 90 days)\n  cleanOldData() {\n    const cutoffDate = new Date();\n    cutoffDate.setDate(cutoffDate.getDate() - 90);\n    const buybackRecords = this.getBuybackRecords();\n    const historicalRecords = this.getHistoricalRecords();\n    const filteredBuyback = buybackRecords.filter(record => new Date(record.timestamp) >= cutoffDate);\n    const filteredHistorical = historicalRecords.filter(record => new Date(record.timestamp) >= cutoffDate);\n    localStorage.setItem(this.BUYBACK_KEY, JSON.stringify(filteredBuyback));\n    localStorage.setItem(this.HISTORICAL_KEY, JSON.stringify(filteredHistorical));\n    return buybackRecords.length - filteredBuyback.length + (historicalRecords.length - filteredHistorical.length);\n  }\n\n  // Close database connection (no-op for localStorage)\n  close() {\n    // No-op for localStorage implementation\n  }\n}\n_DatabaseService = DatabaseService;\nDatabaseService.instance = void 0;","map":{"version":3,"names":["DatabaseService","getInstance","instance","constructor","BUYBACK_KEY","HISTORICAL_KEY","initializeWithSampleData","existingBuyback","localStorage","getItem","existingHistorical","generateSampleData","protocols","name","token","basePrice","baseVolume","buybackRecords","historicalCharts","now","Date","cumulativeData","value","tokens","i","date","setDate","getDate","timestamp","toISOString","forEach","protocol","priceVariance","Math","random","volumeVariance","price","volume","feePercent","dailyBuybackUSD","dailyTokens","min","push","id","length","total_repurchased","total_value_usd","circulating_supply_percent","estimated_annual_buyback","fee_allocation_percent","price_per_token","trading_volume_24h","fee_generation_24h","value_usd","tokens_amount","cumulative_value","cumulative_tokens","setItem","JSON","stringify","insertBuybackRecord","record","records","getBuybackRecords","newId","max","map","r","insertHistoricalData","data","getHistoricalRecords","parse","getLatestBuybackData","latestByProtocol","Object","values","getHistoricalData","days","cutoffDate","filter","recordDate","matchesProtocol","withinTimeframe","sort","a","b","getTime","getBuybackTrends","getPerformanceMetrics","metricsByProtocol","data_points","total_value","supply_reductions","metrics","avg_value_usd","max_value_usd","min_value_usd","avg_supply_reduction","reduce","cleanOldData","historicalRecords","filteredBuyback","filteredHistorical","close","_DatabaseService"],"sources":["/Users/gherardolattanzi/treasury/src/database/browserDb.ts"],"sourcesContent":["// Browser-compatible database service using localStorage\n// This replaces better-sqlite3 for client-side storage\n\nexport interface BuybackRecord {\n  id?: number;\n  protocol: string;\n  token: string;\n  timestamp: string;\n  total_repurchased: number;\n  total_value_usd: number;\n  circulating_supply_percent: number;\n  estimated_annual_buyback: number;\n  fee_allocation_percent: number;\n  price_per_token: number;\n  trading_volume_24h?: number;\n  fee_generation_24h?: number;\n}\n\nexport interface HistoricalChart {\n  id?: number;\n  protocol: string;\n  timestamp: string;\n  value_usd: number;\n  tokens_amount: number;\n  cumulative_value: number;\n  cumulative_tokens: number;\n}\n\nexport class DatabaseService {\n  private static instance: DatabaseService;\n  private readonly BUYBACK_KEY = 'buyback_records';\n  private readonly HISTORICAL_KEY = 'historical_charts';\n\n  public static getInstance(): DatabaseService {\n    if (!DatabaseService.instance) {\n      DatabaseService.instance = new DatabaseService();\n    }\n    return DatabaseService.instance;\n  }\n\n  constructor() {\n    this.initializeWithSampleData();\n  }\n\n  private initializeWithSampleData(): void {\n    // Check if data already exists\n    const existingBuyback = localStorage.getItem(this.BUYBACK_KEY);\n    const existingHistorical = localStorage.getItem(this.HISTORICAL_KEY);\n    \n    if (!existingBuyback || !existingHistorical) {\n      this.generateSampleData();\n    }\n  }\n\n  private generateSampleData(): void {\n    const protocols = [\n      { name: 'Hyperliquid', token: 'HYPE', basePrice: 19.3, baseVolume: 1200000000 },\n      { name: 'Jupiter', token: 'JUP', basePrice: 0.6, baseVolume: 850000000 },\n      { name: 'Aave', token: 'AAVE', basePrice: 192, baseVolume: 45000000 },\n      { name: 'Jito', token: 'JTO', basePrice: 5.0, baseVolume: 320000000 },\n      { name: 'Pump.fun', token: 'PUMP', basePrice: 0.165, baseVolume: 180000000 }\n    ];\n\n    const buybackRecords: BuybackRecord[] = [];\n    const historicalCharts: HistoricalChart[] = [];\n    \n    const now = new Date();\n    let cumulativeData: { [key: string]: { value: number; tokens: number } } = {\n      'Hyperliquid': { value: 350000000, tokens: 18000000 },\n      'Jupiter': { value: 24000000, tokens: 42000000 },\n      'Aave': { value: 20000000, tokens: 115000 },\n      'Jito': { value: 35000000, tokens: 7500000 },\n      'Pump.fun': { value: 20000000, tokens: 125000000 }\n    };\n\n    for (let i = 30; i >= 0; i--) {\n      const date = new Date(now);\n      date.setDate(date.getDate() - i);\n      const timestamp = date.toISOString();\n\n      protocols.forEach(protocol => {\n        // Generate realistic variance\n        const priceVariance = 0.9 + Math.random() * 0.2;\n        const volumeVariance = 0.8 + Math.random() * 0.4;\n        const price = protocol.basePrice * priceVariance;\n        const volume = protocol.baseVolume * volumeVariance;\n        \n        // Calculate buyback amounts\n        let feePercent, dailyBuybackUSD, dailyTokens;\n        \n        if (protocol.name === 'Hyperliquid') {\n          feePercent = 97;\n          dailyBuybackUSD = (volume * 0.0002 * 0.97);\n          dailyTokens = dailyBuybackUSD / price;\n        } else if (protocol.name === 'Jupiter') {\n          feePercent = 50;\n          dailyBuybackUSD = (volume * 0.0001 * 0.5);\n          dailyTokens = dailyBuybackUSD / price;\n        } else { // Aave\n          feePercent = 100;\n          dailyBuybackUSD = Math.min(1000000 / 7, volume * 0.0004);\n          dailyTokens = dailyBuybackUSD / price;\n        }\n\n        // Update cumulative data\n        cumulativeData[protocol.name].value += dailyBuybackUSD;\n        cumulativeData[protocol.name].tokens += dailyTokens;\n\n        // Add buyback record\n        buybackRecords.push({\n          id: buybackRecords.length + 1,\n          protocol: protocol.name,\n          token: protocol.token,\n          timestamp,\n          total_repurchased: cumulativeData[protocol.name].tokens,\n          total_value_usd: cumulativeData[protocol.name].value,\n          circulating_supply_percent: protocol.name === 'Hyperliquid' ? 6.2 : protocol.name === 'Jupiter' ? 3.6 : 0.8,\n          estimated_annual_buyback: protocol.name === 'Hyperliquid' ? 600000000 : protocol.name === 'Jupiter' ? 250000000 : 52000000,\n          fee_allocation_percent: feePercent,\n          price_per_token: price,\n          trading_volume_24h: volume,\n          fee_generation_24h: volume * 0.0002\n        });\n\n        // Add historical chart data\n        historicalCharts.push({\n          id: historicalCharts.length + 1,\n          protocol: protocol.name,\n          timestamp,\n          value_usd: dailyBuybackUSD,\n          tokens_amount: dailyTokens,\n          cumulative_value: cumulativeData[protocol.name].value,\n          cumulative_tokens: cumulativeData[protocol.name].tokens\n        });\n      });\n    }\n\n    localStorage.setItem(this.BUYBACK_KEY, JSON.stringify(buybackRecords));\n    localStorage.setItem(this.HISTORICAL_KEY, JSON.stringify(historicalCharts));\n  }\n\n  // Insert buyback record\n  insertBuybackRecord(record: BuybackRecord): number {\n    const records = this.getBuybackRecords();\n    const newId = Math.max(...records.map(r => r.id || 0), 0) + 1;\n    record.id = newId;\n    records.push(record);\n    localStorage.setItem(this.BUYBACK_KEY, JSON.stringify(records));\n    return newId;\n  }\n\n  // Insert historical chart data\n  insertHistoricalData(data: HistoricalChart): number {\n    const records = this.getHistoricalRecords();\n    const newId = Math.max(...records.map(r => r.id || 0), 0) + 1;\n    data.id = newId;\n    records.push(data);\n    localStorage.setItem(this.HISTORICAL_KEY, JSON.stringify(records));\n    return newId;\n  }\n\n  private getBuybackRecords(): BuybackRecord[] {\n    const data = localStorage.getItem(this.BUYBACK_KEY);\n    return data ? JSON.parse(data) : [];\n  }\n\n  private getHistoricalRecords(): HistoricalChart[] {\n    const data = localStorage.getItem(this.HISTORICAL_KEY);\n    return data ? JSON.parse(data) : [];\n  }\n\n  // Get latest buyback data for all protocols\n  getLatestBuybackData(): BuybackRecord[] {\n    const records = this.getBuybackRecords();\n    const latestByProtocol: { [protocol: string]: BuybackRecord } = {};\n    \n    records.forEach(record => {\n      if (!latestByProtocol[record.protocol] || \n          new Date(record.timestamp) > new Date(latestByProtocol[record.protocol].timestamp)) {\n        latestByProtocol[record.protocol] = record;\n      }\n    });\n\n    return Object.values(latestByProtocol);\n  }\n\n  // Get historical data for charts\n  getHistoricalData(protocol?: string, days: number = 30): HistoricalChart[] {\n    const records = this.getHistoricalRecords();\n    const cutoffDate = new Date();\n    cutoffDate.setDate(cutoffDate.getDate() - days);\n    \n    return records.filter(record => {\n      const recordDate = new Date(record.timestamp);\n      const matchesProtocol = !protocol || record.protocol === protocol;\n      const withinTimeframe = recordDate >= cutoffDate;\n      return matchesProtocol && withinTimeframe;\n    }).sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());\n  }\n\n  // Get buyback trends\n  getBuybackTrends(protocol: string, days: number = 30): any[] {\n    const records = this.getBuybackRecords();\n    const cutoffDate = new Date();\n    cutoffDate.setDate(cutoffDate.getDate() - days);\n    \n    return records\n      .filter(record => {\n        const recordDate = new Date(record.timestamp);\n        return record.protocol === protocol && recordDate >= cutoffDate;\n      })\n      .map(record => ({\n        timestamp: record.timestamp,\n        total_value_usd: record.total_value_usd,\n        total_repurchased: record.total_repurchased,\n        price_per_token: record.price_per_token,\n        trading_volume_24h: record.trading_volume_24h\n      }))\n      .sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());\n  }\n\n  // Get performance metrics\n  getPerformanceMetrics(): any[] {\n    const records = this.getBuybackRecords();\n    const metricsByProtocol: { [protocol: string]: any } = {};\n    \n    records.forEach(record => {\n      if (!metricsByProtocol[record.protocol]) {\n        metricsByProtocol[record.protocol] = {\n          protocol: record.protocol,\n          data_points: 0,\n          total_value: 0,\n          values: [],\n          supply_reductions: []\n        };\n      }\n      \n      const metrics = metricsByProtocol[record.protocol];\n      metrics.data_points++;\n      metrics.total_value += record.total_value_usd;\n      metrics.values.push(record.total_value_usd);\n      metrics.supply_reductions.push(record.circulating_supply_percent);\n    });\n\n    return Object.values(metricsByProtocol).map((metrics: any) => ({\n      protocol: metrics.protocol,\n      data_points: metrics.data_points,\n      avg_value_usd: metrics.total_value / metrics.data_points,\n      max_value_usd: Math.max(...metrics.values),\n      min_value_usd: Math.min(...metrics.values),\n      avg_supply_reduction: metrics.supply_reductions.reduce((a: number, b: number) => a + b, 0) / metrics.supply_reductions.length\n    }));\n  }\n\n  // Clean old data (keep last 90 days)\n  cleanOldData(): number {\n    const cutoffDate = new Date();\n    cutoffDate.setDate(cutoffDate.getDate() - 90);\n    \n    const buybackRecords = this.getBuybackRecords();\n    const historicalRecords = this.getHistoricalRecords();\n    \n    const filteredBuyback = buybackRecords.filter(record => \n      new Date(record.timestamp) >= cutoffDate\n    );\n    const filteredHistorical = historicalRecords.filter(record => \n      new Date(record.timestamp) >= cutoffDate\n    );\n    \n    localStorage.setItem(this.BUYBACK_KEY, JSON.stringify(filteredBuyback));\n    localStorage.setItem(this.HISTORICAL_KEY, JSON.stringify(filteredHistorical));\n    \n    return (buybackRecords.length - filteredBuyback.length) + \n           (historicalRecords.length - filteredHistorical.length);\n  }\n\n  // Close database connection (no-op for localStorage)\n  close(): void {\n    // No-op for localStorage implementation\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}