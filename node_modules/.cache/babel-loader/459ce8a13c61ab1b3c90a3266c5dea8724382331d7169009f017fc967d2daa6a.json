{"ast":null,"code":"var _OptimizedDataService;\n/**\n * Optimized Data Service\n * Clean, modular service with proper error handling, caching, and validation\n */\n\nimport axios from 'axios';\nimport { PROTOCOL_TOKENS, COINGECKO_IDS, MOCK_PRICES, API_ENDPOINTS, API_TIMEOUTS, CACHE_DURATIONS, EXPECTED_PROTOCOL_COUNT } from '../constants';\nimport { formatDate } from '../utils/formatters';\nimport { isValidProtocolToken, isValidPrice, isValidVolume, createError, isNetworkError, createCacheKey, isCacheExpired } from '../utils/helpers';\nimport { DatabaseService } from '../database/browserDb';\n\n/**\n * Service configuration interface\n */\n\n/**\n * Default service configuration\n */\nconst DEFAULT_CONFIG = {\n  baseURL: API_ENDPOINTS.COINGECKO_BASE,\n  timeout: API_TIMEOUTS.DEFAULT,\n  retries: 3,\n  cacheDuration: CACHE_DURATIONS.MEDIUM,\n  enableMockData: true\n};\n\n/**\n * Optimized Data Service Class\n */\nexport class OptimizedDataService {\n  /**\n   * Singleton pattern implementation\n   */\n  static getInstance(config) {\n    if (!OptimizedDataService.instance) {\n      OptimizedDataService.instance = new OptimizedDataService(config);\n    }\n    return OptimizedDataService.instance;\n  }\n\n  /**\n   * Private constructor\n   */\n  constructor(config) {\n    this.config = void 0;\n    this.apiClient = void 0;\n    this.cache = new Map();\n    this.dbService = void 0;\n    this.config = {\n      ...DEFAULT_CONFIG,\n      ...config\n    };\n    this.dbService = DatabaseService.getInstance();\n    this.apiClient = this.createApiClient();\n  }\n\n  /**\n   * Create configured Axios instance\n   */\n  createApiClient() {\n    const client = axios.create({\n      baseURL: this.config.baseURL,\n      timeout: this.config.timeout,\n      headers: {\n        'Content-Type': 'application/json',\n        'Accept': 'application/json'\n      }\n    });\n\n    // Add request interceptor for logging\n    client.interceptors.request.use(config => {\n      var _config$method;\n      console.log(`üöÄ API Request: ${(_config$method = config.method) === null || _config$method === void 0 ? void 0 : _config$method.toUpperCase()} ${config.url}`);\n      return config;\n    }, error => Promise.reject(this.createServiceError('REQUEST_ERROR', error)));\n\n    // Add response interceptor for error handling\n    client.interceptors.response.use(response => {\n      console.log(`‚úÖ API Response: ${response.status} ${response.config.url}`);\n      return response;\n    }, error => {\n      console.error(`‚ùå API Error: ${error.message}`);\n      return Promise.reject(this.createServiceError('RESPONSE_ERROR', error));\n    });\n    return client;\n  }\n\n  /**\n   * Create standardized service error\n   */\n  createServiceError(type, originalError) {\n    const code = isNetworkError(originalError) ? 'NETWORK_ERROR' : 'API_ERROR';\n    const error = createError(`${type}: ${originalError.message}`, code);\n    error.details = originalError;\n    error.timestamp = Date.now();\n    return error;\n  }\n\n  /**\n   * Cache management methods\n   */\n  getCacheEntry(key) {\n    const entry = this.cache.get(key);\n    if (!entry || isCacheExpired(entry.timestamp, this.config.cacheDuration)) {\n      this.cache.delete(key);\n      return null;\n    }\n    return entry.data;\n  }\n  setCacheEntry(key, data) {\n    const entry = {\n      data,\n      timestamp: Date.now(),\n      expiresAt: Date.now() + this.config.cacheDuration\n    };\n    this.cache.set(key, entry);\n  }\n  clearCache() {\n    this.cache.clear();\n  }\n\n  /**\n   * Validation methods\n   */\n  validateProtocolToken(token) {\n    if (!isValidProtocolToken(token)) {\n      throw createError(`Invalid protocol token: ${token}`, 'VALIDATION_ERROR');\n    }\n    return token;\n  }\n  validatePriceData(price, token) {\n    if (!isValidPrice(price)) {\n      console.warn(`Invalid price for ${token}: ${price}, using mock data`);\n      const validToken = token;\n      const coingeckoId = COINGECKO_IDS[validToken];\n      return MOCK_PRICES[coingeckoId] || 1;\n    }\n    return price;\n  }\n\n  /**\n   * API request with retry logic\n   */\n  async apiRequest(config, retries = this.config.retries) {\n    try {\n      const response = await this.apiClient.request(config);\n      return response.data;\n    } catch (error) {\n      if (retries > 0 && isNetworkError(error)) {\n        console.warn(`Retrying API request... ${retries} attempts remaining`);\n        await new Promise(resolve => setTimeout(resolve, 1000));\n        return this.apiRequest(config, retries - 1);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Get token price from CoinGecko API\n   */\n  async getTokenPrice(token) {\n    const validToken = this.validateProtocolToken(token);\n    const coingeckoId = COINGECKO_IDS[validToken];\n    const cacheKey = createCacheKey('price', coingeckoId);\n\n    // Check cache first\n    const cachedPrice = this.getCacheEntry(cacheKey);\n    if (cachedPrice !== null) {\n      return cachedPrice;\n    }\n    try {\n      var _response$coingeckoId;\n      const response = await this.apiRequest({\n        url: `/simple/price`,\n        params: {\n          ids: coingeckoId,\n          vs_currencies: 'usd'\n        }\n      });\n      const price = (_response$coingeckoId = response[coingeckoId]) === null || _response$coingeckoId === void 0 ? void 0 : _response$coingeckoId.usd;\n      if (typeof price !== 'number') {\n        throw createError(`Invalid price response for ${token}`, 'API_ERROR');\n      }\n      const validatedPrice = this.validatePriceData(price, token);\n      this.setCacheEntry(cacheKey, validatedPrice);\n      return validatedPrice;\n    } catch (error) {\n      console.warn(`Failed to fetch price for ${token}, using mock data:`, error);\n      return MOCK_PRICES[coingeckoId] || 1;\n    }\n  }\n\n  /**\n   * Get buyback data for a specific protocol\n   */\n  async getBuybackData(token) {\n    const validToken = this.validateProtocolToken(token);\n    const cacheKey = createCacheKey('buyback', validToken);\n\n    // Check cache first\n    const cachedData = this.getCacheEntry(cacheKey);\n    if (cachedData) {\n      return cachedData;\n    }\n    try {\n      // Get current price\n      const currentPrice = await this.getTokenPrice(validToken);\n\n      // Get mock buyback data from config\n      const mockData = await import('../config/protocols');\n      const protocolData = mockData.MOCK_BUYBACK_DATA[validToken];\n      if (!protocolData) {\n        throw createError(`No mock data available for ${validToken}`, 'VALIDATION_ERROR');\n      }\n\n      // Create buyback data with real price\n      const buybackData = {\n        ...protocolData,\n        lastUpdated: formatDate(new Date())\n      };\n\n      // Validate the data\n      if (!isValidVolume(buybackData.totalValueUSD)) {\n        console.warn(`Invalid volume data for ${validToken}`);\n      }\n      this.setCacheEntry(cacheKey, buybackData);\n      return buybackData;\n    } catch (error) {\n      console.error(`Failed to get buyback data for ${validToken}:`, error);\n      throw this.createServiceError('BUYBACK_DATA_ERROR', error);\n    }\n  }\n\n  /**\n   * Get all buyback data for all protocols\n   */\n  async getAllBuybackData() {\n    const cacheKey = 'all_buyback_data';\n\n    // Check cache first\n    const cachedData = this.getCacheEntry(cacheKey);\n    if (cachedData && cachedData.length === EXPECTED_PROTOCOL_COUNT) {\n      return cachedData;\n    }\n    try {\n      // Try to get data from database first\n      const dbData = this.dbService.getLatestBuybackData();\n      if (dbData.length >= EXPECTED_PROTOCOL_COUNT) {\n        const buybackData = dbData.map(record => this.convertDbRecordToBuybackData(record));\n\n        // Update database with fresh data\n        await this.saveCurrentDataToDb();\n        this.setCacheEntry(cacheKey, buybackData);\n        return buybackData;\n      }\n\n      // Fallback: Fetch fresh data for all protocols\n      console.log('Fetching fresh data for all protocols...');\n      const dataPromises = PROTOCOL_TOKENS.map(token => this.getBuybackData(token));\n      const allData = await Promise.all(dataPromises);\n\n      // Save to database\n      await this.saveDataToDatabase(allData);\n      this.setCacheEntry(cacheKey, allData);\n      return allData;\n    } catch (error) {\n      console.error('Error getting all buyback data:', error);\n\n      // Final fallback: Return mock data for all protocols\n      console.warn('Using fallback mock data for all protocols');\n      const fallbackPromises = PROTOCOL_TOKENS.map(token => this.getBuybackData(token));\n      return Promise.all(fallbackPromises);\n    }\n  }\n\n  /**\n   * Get historical chart data\n   */\n  async getHistoricalChartData(protocol, days = 30) {\n    const cacheKey = createCacheKey('historical', protocol || 'all', days);\n\n    // Check cache first\n    const cachedData = this.getCacheEntry(cacheKey);\n    if (cachedData) {\n      return cachedData;\n    }\n    try {\n      const historicalData = this.dbService.getHistoricalData(protocol, days);\n      this.setCacheEntry(cacheKey, historicalData);\n      return historicalData;\n    } catch (error) {\n      console.error('Error getting historical data:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Database operations\n   */\n  convertDbRecordToBuybackData(record) {\n    return {\n      protocol: record.protocol,\n      token: record.token,\n      totalRepurchased: record.total_repurchased,\n      totalValueUSD: record.total_value_usd,\n      circulatingSupplyPercent: record.circulating_supply_percent,\n      estimatedAnnualBuyback: record.estimated_annual_buyback,\n      feeAllocationPercent: record.fee_allocation_percent,\n      lastUpdated: formatDate(new Date(record.timestamp))\n    };\n  }\n  async saveDataToDatabase(data) {\n    try {\n      // This would integrate with the database service\n      console.log('Saving data to database:', data.length, 'records');\n      // Implementation would go here\n    } catch (error) {\n      console.error('Error saving to database:', error);\n    }\n  }\n  async saveCurrentDataToDb() {\n    try {\n      // Simulate saving current data\n      console.log('Saving current data to database');\n      // Implementation would go here\n    } catch (error) {\n      console.error('Error saving current data:', error);\n    }\n  }\n\n  /**\n   * Utility methods\n   */\n  getCacheStats() {\n    return {\n      size: this.cache.size,\n      entries: Array.from(this.cache.keys())\n    };\n  }\n  clearAllCache() {\n    this.clearCache();\n    console.log('üóëÔ∏è All cache cleared');\n  }\n  async healthCheck() {\n    try {\n      // Test API connectivity\n      await this.apiRequest({\n        url: '/ping',\n        timeout: 3000\n      });\n\n      // Test database connectivity\n      const dbData = this.dbService.getLatestBuybackData();\n      return {\n        status: 'healthy',\n        details: {\n          api: 'connected',\n          database: `${dbData.length} records`,\n          cache: `${this.cache.size} entries`,\n          lastCheck: new Date().toISOString()\n        }\n      };\n    } catch (error) {\n      return {\n        status: 'unhealthy',\n        details: {\n          error: error instanceof Error ? error.message : 'Unknown error',\n          lastCheck: new Date().toISOString()\n        }\n      };\n    }\n  }\n}\n_OptimizedDataService = OptimizedDataService;\nOptimizedDataService.instance = void 0;","map":{"version":3,"names":["axios","PROTOCOL_TOKENS","COINGECKO_IDS","MOCK_PRICES","API_ENDPOINTS","API_TIMEOUTS","CACHE_DURATIONS","EXPECTED_PROTOCOL_COUNT","formatDate","isValidProtocolToken","isValidPrice","isValidVolume","createError","isNetworkError","createCacheKey","isCacheExpired","DatabaseService","DEFAULT_CONFIG","baseURL","COINGECKO_BASE","timeout","DEFAULT","retries","cacheDuration","MEDIUM","enableMockData","OptimizedDataService","getInstance","config","instance","constructor","apiClient","cache","Map","dbService","createApiClient","client","create","headers","interceptors","request","use","_config$method","console","log","method","toUpperCase","url","error","Promise","reject","createServiceError","response","status","message","type","originalError","code","details","timestamp","Date","now","getCacheEntry","key","entry","get","delete","data","setCacheEntry","expiresAt","set","clearCache","clear","validateProtocolToken","token","validatePriceData","price","warn","validToken","coingeckoId","apiRequest","resolve","setTimeout","getTokenPrice","cacheKey","cachedPrice","_response$coingeckoId","params","ids","vs_currencies","usd","validatedPrice","getBuybackData","cachedData","currentPrice","mockData","protocolData","MOCK_BUYBACK_DATA","buybackData","lastUpdated","totalValueUSD","getAllBuybackData","length","dbData","getLatestBuybackData","map","record","convertDbRecordToBuybackData","saveCurrentDataToDb","dataPromises","allData","all","saveDataToDatabase","fallbackPromises","getHistoricalChartData","protocol","days","historicalData","getHistoricalData","totalRepurchased","total_repurchased","total_value_usd","circulatingSupplyPercent","circulating_supply_percent","estimatedAnnualBuyback","estimated_annual_buyback","feeAllocationPercent","fee_allocation_percent","getCacheStats","size","entries","Array","from","keys","clearAllCache","healthCheck","api","database","lastCheck","toISOString","Error","_OptimizedDataService"],"sources":["/Users/gherardolattanzi/treasury/src/services/optimizedDataService.ts"],"sourcesContent":["/**\n * Optimized Data Service\n * Clean, modular service with proper error handling, caching, and validation\n */\n\nimport axios, { AxiosInstance, AxiosRequestConfig } from 'axios';\nimport { \n  PROTOCOL_TOKENS, \n  COINGECKO_IDS, \n  MOCK_PRICES, \n  BASE_VOLUMES,\n  DAILY_ACTIVE_USERS,\n  API_ENDPOINTS,\n  API_TIMEOUTS,\n  CACHE_DURATIONS,\n  EXPECTED_PROTOCOL_COUNT \n} from '../constants';\nimport { \n  formatCurrency, \n  formatDate,\n  getRelativeTime \n} from '../utils/formatters';\nimport {\n  isValidProtocolToken,\n  isValidPrice,\n  isValidVolume,\n  createError,\n  isNetworkError,\n  createCacheKey,\n  isCacheExpired,\n  safeLocalStorageGet,\n  safeLocalStorageSet\n} from '../utils/helpers';\nimport { DatabaseService } from '../database/browserDb';\nimport type { \n  BuybackData, \n  ProtocolToken, \n  CacheEntry, \n  ApiResponse,\n  AppError,\n  ErrorCode \n} from '../types';\n\n/**\n * Service configuration interface\n */\ninterface ServiceConfig {\n  baseURL?: string;\n  timeout?: number;\n  retries?: number;\n  cacheDuration?: number;\n  enableMockData?: boolean;\n}\n\n/**\n * Default service configuration\n */\nconst DEFAULT_CONFIG: Required<ServiceConfig> = {\n  baseURL: API_ENDPOINTS.COINGECKO_BASE,\n  timeout: API_TIMEOUTS.DEFAULT,\n  retries: 3,\n  cacheDuration: CACHE_DURATIONS.MEDIUM,\n  enableMockData: true,\n};\n\n/**\n * Optimized Data Service Class\n */\nexport class OptimizedDataService {\n  private static instance: OptimizedDataService;\n  private readonly config: Required<ServiceConfig>;\n  private readonly apiClient: AxiosInstance;\n  private readonly cache = new Map<string, CacheEntry>();\n  private readonly dbService: DatabaseService;\n\n  /**\n   * Singleton pattern implementation\n   */\n  public static getInstance(config?: ServiceConfig): OptimizedDataService {\n    if (!OptimizedDataService.instance) {\n      OptimizedDataService.instance = new OptimizedDataService(config);\n    }\n    return OptimizedDataService.instance;\n  }\n\n  /**\n   * Private constructor\n   */\n  private constructor(config?: ServiceConfig) {\n    this.config = { ...DEFAULT_CONFIG, ...config };\n    this.dbService = DatabaseService.getInstance();\n    this.apiClient = this.createApiClient();\n  }\n\n  /**\n   * Create configured Axios instance\n   */\n  private createApiClient(): AxiosInstance {\n    const client = axios.create({\n      baseURL: this.config.baseURL,\n      timeout: this.config.timeout,\n      headers: {\n        'Content-Type': 'application/json',\n        'Accept': 'application/json',\n      },\n    });\n\n    // Add request interceptor for logging\n    client.interceptors.request.use(\n      (config) => {\n        console.log(`üöÄ API Request: ${config.method?.toUpperCase()} ${config.url}`);\n        return config;\n      },\n      (error) => Promise.reject(this.createServiceError('REQUEST_ERROR', error))\n    );\n\n    // Add response interceptor for error handling\n    client.interceptors.response.use(\n      (response) => {\n        console.log(`‚úÖ API Response: ${response.status} ${response.config.url}`);\n        return response;\n      },\n      (error) => {\n        console.error(`‚ùå API Error: ${error.message}`);\n        return Promise.reject(this.createServiceError('RESPONSE_ERROR', error));\n      }\n    );\n\n    return client;\n  }\n\n  /**\n   * Create standardized service error\n   */\n  private createServiceError(type: string, originalError: any): AppError {\n    const code: ErrorCode = isNetworkError(originalError) ? 'NETWORK_ERROR' : 'API_ERROR';\n    const error = createError(`${type}: ${originalError.message}`, code) as AppError;\n    error.details = originalError;\n    error.timestamp = Date.now();\n    return error;\n  }\n\n  /**\n   * Cache management methods\n   */\n  private getCacheEntry<T>(key: string): T | null {\n    const entry = this.cache.get(key);\n    if (!entry || isCacheExpired(entry.timestamp, this.config.cacheDuration)) {\n      this.cache.delete(key);\n      return null;\n    }\n    return entry.data;\n  }\n\n  private setCacheEntry<T>(key: string, data: T): void {\n    const entry: CacheEntry<T> = {\n      data,\n      timestamp: Date.now(),\n      expiresAt: Date.now() + this.config.cacheDuration,\n    };\n    this.cache.set(key, entry);\n  }\n\n  private clearCache(): void {\n    this.cache.clear();\n  }\n\n  /**\n   * Validation methods\n   */\n  private validateProtocolToken(token: string): ProtocolToken {\n    if (!isValidProtocolToken(token)) {\n      throw createError(`Invalid protocol token: ${token}`, 'VALIDATION_ERROR');\n    }\n    return token as ProtocolToken;\n  }\n\n  private validatePriceData(price: number, token: string): number {\n    if (!isValidPrice(price)) {\n      console.warn(`Invalid price for ${token}: ${price}, using mock data`);\n      const validToken = token as ProtocolToken;\n      const coingeckoId = COINGECKO_IDS[validToken];\n      return MOCK_PRICES[coingeckoId as keyof typeof MOCK_PRICES] || 1;\n    }\n    return price;\n  }\n\n  /**\n   * API request with retry logic\n   */\n  private async apiRequest<T>(\n    config: AxiosRequestConfig,\n    retries: number = this.config.retries\n  ): Promise<T> {\n    try {\n      const response = await this.apiClient.request<T>(config);\n      return response.data;\n    } catch (error) {\n      if (retries > 0 && isNetworkError(error)) {\n        console.warn(`Retrying API request... ${retries} attempts remaining`);\n        await new Promise(resolve => setTimeout(resolve, 1000));\n        return this.apiRequest<T>(config, retries - 1);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Get token price from CoinGecko API\n   */\n  async getTokenPrice(token: ProtocolToken): Promise<number> {\n    const validToken = this.validateProtocolToken(token);\n    const coingeckoId = COINGECKO_IDS[validToken];\n    const cacheKey = createCacheKey('price', coingeckoId);\n\n    // Check cache first\n    const cachedPrice = this.getCacheEntry<number>(cacheKey);\n    if (cachedPrice !== null) {\n      return cachedPrice;\n    }\n\n    try {\n      const response = await this.apiRequest<Record<string, { usd: number }>>({\n        url: `/simple/price`,\n        params: {\n          ids: coingeckoId,\n          vs_currencies: 'usd',\n        },\n      });\n\n      const price = response[coingeckoId]?.usd;\n      if (typeof price !== 'number') {\n        throw createError(`Invalid price response for ${token}`, 'API_ERROR');\n      }\n\n      const validatedPrice = this.validatePriceData(price, token);\n      this.setCacheEntry(cacheKey, validatedPrice);\n      return validatedPrice;\n\n    } catch (error) {\n      console.warn(`Failed to fetch price for ${token}, using mock data:`, error);\n      return MOCK_PRICES[coingeckoId as keyof typeof MOCK_PRICES] || 1;\n    }\n  }\n\n  /**\n   * Get buyback data for a specific protocol\n   */\n  async getBuybackData(token: ProtocolToken): Promise<BuybackData> {\n    const validToken = this.validateProtocolToken(token);\n    const cacheKey = createCacheKey('buyback', validToken);\n\n    // Check cache first\n    const cachedData = this.getCacheEntry<BuybackData>(cacheKey);\n    if (cachedData) {\n      return cachedData;\n    }\n\n    try {\n      // Get current price\n      const currentPrice = await this.getTokenPrice(validToken);\n      \n      // Get mock buyback data from config\n      const mockData = await import('../config/protocols');\n      const protocolData = (mockData.MOCK_BUYBACK_DATA as any)[validToken];\n      \n      if (!protocolData) {\n        throw createError(`No mock data available for ${validToken}`, 'VALIDATION_ERROR');\n      }\n\n      // Create buyback data with real price\n      const buybackData: BuybackData = {\n        ...protocolData,\n        lastUpdated: formatDate(new Date()),\n      };\n\n      // Validate the data\n      if (!isValidVolume(buybackData.totalValueUSD)) {\n        console.warn(`Invalid volume data for ${validToken}`);\n      }\n\n      this.setCacheEntry(cacheKey, buybackData);\n      return buybackData;\n\n    } catch (error) {\n      console.error(`Failed to get buyback data for ${validToken}:`, error);\n      throw this.createServiceError('BUYBACK_DATA_ERROR', error);\n    }\n  }\n\n  /**\n   * Get all buyback data for all protocols\n   */\n  async getAllBuybackData(): Promise<BuybackData[]> {\n    const cacheKey = 'all_buyback_data';\n\n    // Check cache first\n    const cachedData = this.getCacheEntry<BuybackData[]>(cacheKey);\n    if (cachedData && cachedData.length === EXPECTED_PROTOCOL_COUNT) {\n      return cachedData;\n    }\n\n    try {\n      // Try to get data from database first\n      const dbData = this.dbService.getLatestBuybackData();\n      \n      if (dbData.length >= EXPECTED_PROTOCOL_COUNT) {\n        const buybackData = dbData.map(record => this.convertDbRecordToBuybackData(record));\n        \n        // Update database with fresh data\n        await this.saveCurrentDataToDb();\n        \n        this.setCacheEntry(cacheKey, buybackData);\n        return buybackData;\n      }\n\n      // Fallback: Fetch fresh data for all protocols\n      console.log('Fetching fresh data for all protocols...');\n      const dataPromises = PROTOCOL_TOKENS.map(token => this.getBuybackData(token));\n      const allData = await Promise.all(dataPromises);\n\n      // Save to database\n      await this.saveDataToDatabase(allData);\n      \n      this.setCacheEntry(cacheKey, allData);\n      return allData;\n\n    } catch (error) {\n      console.error('Error getting all buyback data:', error);\n      \n      // Final fallback: Return mock data for all protocols\n      console.warn('Using fallback mock data for all protocols');\n      const fallbackPromises = PROTOCOL_TOKENS.map(token => this.getBuybackData(token));\n      return Promise.all(fallbackPromises);\n    }\n  }\n\n  /**\n   * Get historical chart data\n   */\n  async getHistoricalChartData(protocol?: string, days: number = 30): Promise<any[]> {\n    const cacheKey = createCacheKey('historical', protocol || 'all', days);\n\n    // Check cache first\n    const cachedData = this.getCacheEntry<any[]>(cacheKey);\n    if (cachedData) {\n      return cachedData;\n    }\n\n    try {\n      const historicalData = this.dbService.getHistoricalData(protocol, days);\n      this.setCacheEntry(cacheKey, historicalData);\n      return historicalData;\n\n    } catch (error) {\n      console.error('Error getting historical data:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Database operations\n   */\n  private convertDbRecordToBuybackData(record: any): BuybackData {\n    return {\n      protocol: record.protocol,\n      token: record.token,\n      totalRepurchased: record.total_repurchased,\n      totalValueUSD: record.total_value_usd,\n      circulatingSupplyPercent: record.circulating_supply_percent,\n      estimatedAnnualBuyback: record.estimated_annual_buyback,\n      feeAllocationPercent: record.fee_allocation_percent,\n      lastUpdated: formatDate(new Date(record.timestamp)),\n    };\n  }\n\n  private async saveDataToDatabase(data: BuybackData[]): Promise<void> {\n    try {\n      // This would integrate with the database service\n      console.log('Saving data to database:', data.length, 'records');\n      // Implementation would go here\n    } catch (error) {\n      console.error('Error saving to database:', error);\n    }\n  }\n\n  private async saveCurrentDataToDb(): Promise<void> {\n    try {\n      // Simulate saving current data\n      console.log('Saving current data to database');\n      // Implementation would go here\n    } catch (error) {\n      console.error('Error saving current data:', error);\n    }\n  }\n\n  /**\n   * Utility methods\n   */\n  public getCacheStats(): { size: number; entries: string[] } {\n    return {\n      size: this.cache.size,\n      entries: Array.from(this.cache.keys()),\n    };\n  }\n\n  public clearAllCache(): void {\n    this.clearCache();\n    console.log('üóëÔ∏è All cache cleared');\n  }\n\n  public async healthCheck(): Promise<{ status: 'healthy' | 'degraded' | 'unhealthy'; details: any }> {\n    try {\n      // Test API connectivity\n      await this.apiRequest({ url: '/ping', timeout: 3000 });\n      \n      // Test database connectivity\n      const dbData = this.dbService.getLatestBuybackData();\n      \n      return {\n        status: 'healthy',\n        details: {\n          api: 'connected',\n          database: `${dbData.length} records`,\n          cache: `${this.cache.size} entries`,\n          lastCheck: new Date().toISOString(),\n        },\n      };\n    } catch (error) {\n      return {\n        status: 'unhealthy',\n        details: {\n          error: error instanceof Error ? error.message : 'Unknown error',\n          lastCheck: new Date().toISOString(),\n        },\n      };\n    }\n  }\n}"],"mappings":";AAAA;AACA;AACA;AACA;;AAEA,OAAOA,KAAK,MAA6C,OAAO;AAChE,SACEC,eAAe,EACfC,aAAa,EACbC,WAAW,EAGXC,aAAa,EACbC,YAAY,EACZC,eAAe,EACfC,uBAAuB,QAClB,cAAc;AACrB,SAEEC,UAAU,QAEL,qBAAqB;AAC5B,SACEC,oBAAoB,EACpBC,YAAY,EACZC,aAAa,EACbC,WAAW,EACXC,cAAc,EACdC,cAAc,EACdC,cAAc,QAGT,kBAAkB;AACzB,SAASC,eAAe,QAAQ,uBAAuB;;AAUvD;AACA;AACA;;AASA;AACA;AACA;AACA,MAAMC,cAAuC,GAAG;EAC9CC,OAAO,EAAEd,aAAa,CAACe,cAAc;EACrCC,OAAO,EAAEf,YAAY,CAACgB,OAAO;EAC7BC,OAAO,EAAE,CAAC;EACVC,aAAa,EAAEjB,eAAe,CAACkB,MAAM;EACrCC,cAAc,EAAE;AAClB,CAAC;;AAED;AACA;AACA;AACA,OAAO,MAAMC,oBAAoB,CAAC;EAOhC;AACF;AACA;EACE,OAAcC,WAAWA,CAACC,MAAsB,EAAwB;IACtE,IAAI,CAACF,oBAAoB,CAACG,QAAQ,EAAE;MAClCH,oBAAoB,CAACG,QAAQ,GAAG,IAAIH,oBAAoB,CAACE,MAAM,CAAC;IAClE;IACA,OAAOF,oBAAoB,CAACG,QAAQ;EACtC;;EAEA;AACF;AACA;EACUC,WAAWA,CAACF,MAAsB,EAAE;IAAA,KAlB3BA,MAAM;IAAA,KACNG,SAAS;IAAA,KACTC,KAAK,GAAG,IAAIC,GAAG,CAAqB,CAAC;IAAA,KACrCC,SAAS;IAgBxB,IAAI,CAACN,MAAM,GAAG;MAAE,GAAGX,cAAc;MAAE,GAAGW;IAAO,CAAC;IAC9C,IAAI,CAACM,SAAS,GAAGlB,eAAe,CAACW,WAAW,CAAC,CAAC;IAC9C,IAAI,CAACI,SAAS,GAAG,IAAI,CAACI,eAAe,CAAC,CAAC;EACzC;;EAEA;AACF;AACA;EACUA,eAAeA,CAAA,EAAkB;IACvC,MAAMC,MAAM,GAAGpC,KAAK,CAACqC,MAAM,CAAC;MAC1BnB,OAAO,EAAE,IAAI,CAACU,MAAM,CAACV,OAAO;MAC5BE,OAAO,EAAE,IAAI,CAACQ,MAAM,CAACR,OAAO;MAC5BkB,OAAO,EAAE;QACP,cAAc,EAAE,kBAAkB;QAClC,QAAQ,EAAE;MACZ;IACF,CAAC,CAAC;;IAEF;IACAF,MAAM,CAACG,YAAY,CAACC,OAAO,CAACC,GAAG,CAC5Bb,MAAM,IAAK;MAAA,IAAAc,cAAA;MACVC,OAAO,CAACC,GAAG,CAAC,oBAAAF,cAAA,GAAmBd,MAAM,CAACiB,MAAM,cAAAH,cAAA,uBAAbA,cAAA,CAAeI,WAAW,CAAC,CAAC,IAAIlB,MAAM,CAACmB,GAAG,EAAE,CAAC;MAC5E,OAAOnB,MAAM;IACf,CAAC,EACAoB,KAAK,IAAKC,OAAO,CAACC,MAAM,CAAC,IAAI,CAACC,kBAAkB,CAAC,eAAe,EAAEH,KAAK,CAAC,CAC3E,CAAC;;IAED;IACAZ,MAAM,CAACG,YAAY,CAACa,QAAQ,CAACX,GAAG,CAC7BW,QAAQ,IAAK;MACZT,OAAO,CAACC,GAAG,CAAC,mBAAmBQ,QAAQ,CAACC,MAAM,IAAID,QAAQ,CAACxB,MAAM,CAACmB,GAAG,EAAE,CAAC;MACxE,OAAOK,QAAQ;IACjB,CAAC,EACAJ,KAAK,IAAK;MACTL,OAAO,CAACK,KAAK,CAAC,gBAAgBA,KAAK,CAACM,OAAO,EAAE,CAAC;MAC9C,OAAOL,OAAO,CAACC,MAAM,CAAC,IAAI,CAACC,kBAAkB,CAAC,gBAAgB,EAAEH,KAAK,CAAC,CAAC;IACzE,CACF,CAAC;IAED,OAAOZ,MAAM;EACf;;EAEA;AACF;AACA;EACUe,kBAAkBA,CAACI,IAAY,EAAEC,aAAkB,EAAY;IACrE,MAAMC,IAAe,GAAG5C,cAAc,CAAC2C,aAAa,CAAC,GAAG,eAAe,GAAG,WAAW;IACrF,MAAMR,KAAK,GAAGpC,WAAW,CAAC,GAAG2C,IAAI,KAAKC,aAAa,CAACF,OAAO,EAAE,EAAEG,IAAI,CAAa;IAChFT,KAAK,CAACU,OAAO,GAAGF,aAAa;IAC7BR,KAAK,CAACW,SAAS,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC;IAC5B,OAAOb,KAAK;EACd;;EAEA;AACF;AACA;EACUc,aAAaA,CAAIC,GAAW,EAAY;IAC9C,MAAMC,KAAK,GAAG,IAAI,CAAChC,KAAK,CAACiC,GAAG,CAACF,GAAG,CAAC;IACjC,IAAI,CAACC,KAAK,IAAIjD,cAAc,CAACiD,KAAK,CAACL,SAAS,EAAE,IAAI,CAAC/B,MAAM,CAACL,aAAa,CAAC,EAAE;MACxE,IAAI,CAACS,KAAK,CAACkC,MAAM,CAACH,GAAG,CAAC;MACtB,OAAO,IAAI;IACb;IACA,OAAOC,KAAK,CAACG,IAAI;EACnB;EAEQC,aAAaA,CAAIL,GAAW,EAAEI,IAAO,EAAQ;IACnD,MAAMH,KAAoB,GAAG;MAC3BG,IAAI;MACJR,SAAS,EAAEC,IAAI,CAACC,GAAG,CAAC,CAAC;MACrBQ,SAAS,EAAET,IAAI,CAACC,GAAG,CAAC,CAAC,GAAG,IAAI,CAACjC,MAAM,CAACL;IACtC,CAAC;IACD,IAAI,CAACS,KAAK,CAACsC,GAAG,CAACP,GAAG,EAAEC,KAAK,CAAC;EAC5B;EAEQO,UAAUA,CAAA,EAAS;IACzB,IAAI,CAACvC,KAAK,CAACwC,KAAK,CAAC,CAAC;EACpB;;EAEA;AACF;AACA;EACUC,qBAAqBA,CAACC,KAAa,EAAiB;IAC1D,IAAI,CAACjE,oBAAoB,CAACiE,KAAK,CAAC,EAAE;MAChC,MAAM9D,WAAW,CAAC,2BAA2B8D,KAAK,EAAE,EAAE,kBAAkB,CAAC;IAC3E;IACA,OAAOA,KAAK;EACd;EAEQC,iBAAiBA,CAACC,KAAa,EAAEF,KAAa,EAAU;IAC9D,IAAI,CAAChE,YAAY,CAACkE,KAAK,CAAC,EAAE;MACxBjC,OAAO,CAACkC,IAAI,CAAC,qBAAqBH,KAAK,KAAKE,KAAK,mBAAmB,CAAC;MACrE,MAAME,UAAU,GAAGJ,KAAsB;MACzC,MAAMK,WAAW,GAAG7E,aAAa,CAAC4E,UAAU,CAAC;MAC7C,OAAO3E,WAAW,CAAC4E,WAAW,CAA6B,IAAI,CAAC;IAClE;IACA,OAAOH,KAAK;EACd;;EAEA;AACF;AACA;EACE,MAAcI,UAAUA,CACtBpD,MAA0B,EAC1BN,OAAe,GAAG,IAAI,CAACM,MAAM,CAACN,OAAO,EACzB;IACZ,IAAI;MACF,MAAM8B,QAAQ,GAAG,MAAM,IAAI,CAACrB,SAAS,CAACS,OAAO,CAAIZ,MAAM,CAAC;MACxD,OAAOwB,QAAQ,CAACe,IAAI;IACtB,CAAC,CAAC,OAAOnB,KAAK,EAAE;MACd,IAAI1B,OAAO,GAAG,CAAC,IAAIT,cAAc,CAACmC,KAAK,CAAC,EAAE;QACxCL,OAAO,CAACkC,IAAI,CAAC,2BAA2BvD,OAAO,qBAAqB,CAAC;QACrE,MAAM,IAAI2B,OAAO,CAACgC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAE,IAAI,CAAC,CAAC;QACvD,OAAO,IAAI,CAACD,UAAU,CAAIpD,MAAM,EAAEN,OAAO,GAAG,CAAC,CAAC;MAChD;MACA,MAAM0B,KAAK;IACb;EACF;;EAEA;AACF;AACA;EACE,MAAMmC,aAAaA,CAACT,KAAoB,EAAmB;IACzD,MAAMI,UAAU,GAAG,IAAI,CAACL,qBAAqB,CAACC,KAAK,CAAC;IACpD,MAAMK,WAAW,GAAG7E,aAAa,CAAC4E,UAAU,CAAC;IAC7C,MAAMM,QAAQ,GAAGtE,cAAc,CAAC,OAAO,EAAEiE,WAAW,CAAC;;IAErD;IACA,MAAMM,WAAW,GAAG,IAAI,CAACvB,aAAa,CAASsB,QAAQ,CAAC;IACxD,IAAIC,WAAW,KAAK,IAAI,EAAE;MACxB,OAAOA,WAAW;IACpB;IAEA,IAAI;MAAA,IAAAC,qBAAA;MACF,MAAMlC,QAAQ,GAAG,MAAM,IAAI,CAAC4B,UAAU,CAAkC;QACtEjC,GAAG,EAAE,eAAe;QACpBwC,MAAM,EAAE;UACNC,GAAG,EAAET,WAAW;UAChBU,aAAa,EAAE;QACjB;MACF,CAAC,CAAC;MAEF,MAAMb,KAAK,IAAAU,qBAAA,GAAGlC,QAAQ,CAAC2B,WAAW,CAAC,cAAAO,qBAAA,uBAArBA,qBAAA,CAAuBI,GAAG;MACxC,IAAI,OAAOd,KAAK,KAAK,QAAQ,EAAE;QAC7B,MAAMhE,WAAW,CAAC,8BAA8B8D,KAAK,EAAE,EAAE,WAAW,CAAC;MACvE;MAEA,MAAMiB,cAAc,GAAG,IAAI,CAAChB,iBAAiB,CAACC,KAAK,EAAEF,KAAK,CAAC;MAC3D,IAAI,CAACN,aAAa,CAACgB,QAAQ,EAAEO,cAAc,CAAC;MAC5C,OAAOA,cAAc;IAEvB,CAAC,CAAC,OAAO3C,KAAK,EAAE;MACdL,OAAO,CAACkC,IAAI,CAAC,6BAA6BH,KAAK,oBAAoB,EAAE1B,KAAK,CAAC;MAC3E,OAAO7C,WAAW,CAAC4E,WAAW,CAA6B,IAAI,CAAC;IAClE;EACF;;EAEA;AACF;AACA;EACE,MAAMa,cAAcA,CAAClB,KAAoB,EAAwB;IAC/D,MAAMI,UAAU,GAAG,IAAI,CAACL,qBAAqB,CAACC,KAAK,CAAC;IACpD,MAAMU,QAAQ,GAAGtE,cAAc,CAAC,SAAS,EAAEgE,UAAU,CAAC;;IAEtD;IACA,MAAMe,UAAU,GAAG,IAAI,CAAC/B,aAAa,CAAcsB,QAAQ,CAAC;IAC5D,IAAIS,UAAU,EAAE;MACd,OAAOA,UAAU;IACnB;IAEA,IAAI;MACF;MACA,MAAMC,YAAY,GAAG,MAAM,IAAI,CAACX,aAAa,CAACL,UAAU,CAAC;;MAEzD;MACA,MAAMiB,QAAQ,GAAG,MAAM,MAAM,CAAC,qBAAqB,CAAC;MACpD,MAAMC,YAAY,GAAID,QAAQ,CAACE,iBAAiB,CAASnB,UAAU,CAAC;MAEpE,IAAI,CAACkB,YAAY,EAAE;QACjB,MAAMpF,WAAW,CAAC,8BAA8BkE,UAAU,EAAE,EAAE,kBAAkB,CAAC;MACnF;;MAEA;MACA,MAAMoB,WAAwB,GAAG;QAC/B,GAAGF,YAAY;QACfG,WAAW,EAAE3F,UAAU,CAAC,IAAIoD,IAAI,CAAC,CAAC;MACpC,CAAC;;MAED;MACA,IAAI,CAACjD,aAAa,CAACuF,WAAW,CAACE,aAAa,CAAC,EAAE;QAC7CzD,OAAO,CAACkC,IAAI,CAAC,2BAA2BC,UAAU,EAAE,CAAC;MACvD;MAEA,IAAI,CAACV,aAAa,CAACgB,QAAQ,EAAEc,WAAW,CAAC;MACzC,OAAOA,WAAW;IAEpB,CAAC,CAAC,OAAOlD,KAAK,EAAE;MACdL,OAAO,CAACK,KAAK,CAAC,kCAAkC8B,UAAU,GAAG,EAAE9B,KAAK,CAAC;MACrE,MAAM,IAAI,CAACG,kBAAkB,CAAC,oBAAoB,EAAEH,KAAK,CAAC;IAC5D;EACF;;EAEA;AACF;AACA;EACE,MAAMqD,iBAAiBA,CAAA,EAA2B;IAChD,MAAMjB,QAAQ,GAAG,kBAAkB;;IAEnC;IACA,MAAMS,UAAU,GAAG,IAAI,CAAC/B,aAAa,CAAgBsB,QAAQ,CAAC;IAC9D,IAAIS,UAAU,IAAIA,UAAU,CAACS,MAAM,KAAK/F,uBAAuB,EAAE;MAC/D,OAAOsF,UAAU;IACnB;IAEA,IAAI;MACF;MACA,MAAMU,MAAM,GAAG,IAAI,CAACrE,SAAS,CAACsE,oBAAoB,CAAC,CAAC;MAEpD,IAAID,MAAM,CAACD,MAAM,IAAI/F,uBAAuB,EAAE;QAC5C,MAAM2F,WAAW,GAAGK,MAAM,CAACE,GAAG,CAACC,MAAM,IAAI,IAAI,CAACC,4BAA4B,CAACD,MAAM,CAAC,CAAC;;QAEnF;QACA,MAAM,IAAI,CAACE,mBAAmB,CAAC,CAAC;QAEhC,IAAI,CAACxC,aAAa,CAACgB,QAAQ,EAAEc,WAAW,CAAC;QACzC,OAAOA,WAAW;MACpB;;MAEA;MACAvD,OAAO,CAACC,GAAG,CAAC,0CAA0C,CAAC;MACvD,MAAMiE,YAAY,GAAG5G,eAAe,CAACwG,GAAG,CAAC/B,KAAK,IAAI,IAAI,CAACkB,cAAc,CAAClB,KAAK,CAAC,CAAC;MAC7E,MAAMoC,OAAO,GAAG,MAAM7D,OAAO,CAAC8D,GAAG,CAACF,YAAY,CAAC;;MAE/C;MACA,MAAM,IAAI,CAACG,kBAAkB,CAACF,OAAO,CAAC;MAEtC,IAAI,CAAC1C,aAAa,CAACgB,QAAQ,EAAE0B,OAAO,CAAC;MACrC,OAAOA,OAAO;IAEhB,CAAC,CAAC,OAAO9D,KAAK,EAAE;MACdL,OAAO,CAACK,KAAK,CAAC,iCAAiC,EAAEA,KAAK,CAAC;;MAEvD;MACAL,OAAO,CAACkC,IAAI,CAAC,4CAA4C,CAAC;MAC1D,MAAMoC,gBAAgB,GAAGhH,eAAe,CAACwG,GAAG,CAAC/B,KAAK,IAAI,IAAI,CAACkB,cAAc,CAAClB,KAAK,CAAC,CAAC;MACjF,OAAOzB,OAAO,CAAC8D,GAAG,CAACE,gBAAgB,CAAC;IACtC;EACF;;EAEA;AACF;AACA;EACE,MAAMC,sBAAsBA,CAACC,QAAiB,EAAEC,IAAY,GAAG,EAAE,EAAkB;IACjF,MAAMhC,QAAQ,GAAGtE,cAAc,CAAC,YAAY,EAAEqG,QAAQ,IAAI,KAAK,EAAEC,IAAI,CAAC;;IAEtE;IACA,MAAMvB,UAAU,GAAG,IAAI,CAAC/B,aAAa,CAAQsB,QAAQ,CAAC;IACtD,IAAIS,UAAU,EAAE;MACd,OAAOA,UAAU;IACnB;IAEA,IAAI;MACF,MAAMwB,cAAc,GAAG,IAAI,CAACnF,SAAS,CAACoF,iBAAiB,CAACH,QAAQ,EAAEC,IAAI,CAAC;MACvE,IAAI,CAAChD,aAAa,CAACgB,QAAQ,EAAEiC,cAAc,CAAC;MAC5C,OAAOA,cAAc;IAEvB,CAAC,CAAC,OAAOrE,KAAK,EAAE;MACdL,OAAO,CAACK,KAAK,CAAC,gCAAgC,EAAEA,KAAK,CAAC;MACtD,OAAO,EAAE;IACX;EACF;;EAEA;AACF;AACA;EACU2D,4BAA4BA,CAACD,MAAW,EAAe;IAC7D,OAAO;MACLS,QAAQ,EAAET,MAAM,CAACS,QAAQ;MACzBzC,KAAK,EAAEgC,MAAM,CAAChC,KAAK;MACnB6C,gBAAgB,EAAEb,MAAM,CAACc,iBAAiB;MAC1CpB,aAAa,EAAEM,MAAM,CAACe,eAAe;MACrCC,wBAAwB,EAAEhB,MAAM,CAACiB,0BAA0B;MAC3DC,sBAAsB,EAAElB,MAAM,CAACmB,wBAAwB;MACvDC,oBAAoB,EAAEpB,MAAM,CAACqB,sBAAsB;MACnD5B,WAAW,EAAE3F,UAAU,CAAC,IAAIoD,IAAI,CAAC8C,MAAM,CAAC/C,SAAS,CAAC;IACpD,CAAC;EACH;EAEA,MAAcqD,kBAAkBA,CAAC7C,IAAmB,EAAiB;IACnE,IAAI;MACF;MACAxB,OAAO,CAACC,GAAG,CAAC,0BAA0B,EAAEuB,IAAI,CAACmC,MAAM,EAAE,SAAS,CAAC;MAC/D;IACF,CAAC,CAAC,OAAOtD,KAAK,EAAE;MACdL,OAAO,CAACK,KAAK,CAAC,2BAA2B,EAAEA,KAAK,CAAC;IACnD;EACF;EAEA,MAAc4D,mBAAmBA,CAAA,EAAkB;IACjD,IAAI;MACF;MACAjE,OAAO,CAACC,GAAG,CAAC,iCAAiC,CAAC;MAC9C;IACF,CAAC,CAAC,OAAOI,KAAK,EAAE;MACdL,OAAO,CAACK,KAAK,CAAC,4BAA4B,EAAEA,KAAK,CAAC;IACpD;EACF;;EAEA;AACF;AACA;EACSgF,aAAaA,CAAA,EAAwC;IAC1D,OAAO;MACLC,IAAI,EAAE,IAAI,CAACjG,KAAK,CAACiG,IAAI;MACrBC,OAAO,EAAEC,KAAK,CAACC,IAAI,CAAC,IAAI,CAACpG,KAAK,CAACqG,IAAI,CAAC,CAAC;IACvC,CAAC;EACH;EAEOC,aAAaA,CAAA,EAAS;IAC3B,IAAI,CAAC/D,UAAU,CAAC,CAAC;IACjB5B,OAAO,CAACC,GAAG,CAAC,uBAAuB,CAAC;EACtC;EAEA,MAAa2F,WAAWA,CAAA,EAA4E;IAClG,IAAI;MACF;MACA,MAAM,IAAI,CAACvD,UAAU,CAAC;QAAEjC,GAAG,EAAE,OAAO;QAAE3B,OAAO,EAAE;MAAK,CAAC,CAAC;;MAEtD;MACA,MAAMmF,MAAM,GAAG,IAAI,CAACrE,SAAS,CAACsE,oBAAoB,CAAC,CAAC;MAEpD,OAAO;QACLnD,MAAM,EAAE,SAAS;QACjBK,OAAO,EAAE;UACP8E,GAAG,EAAE,WAAW;UAChBC,QAAQ,EAAE,GAAGlC,MAAM,CAACD,MAAM,UAAU;UACpCtE,KAAK,EAAE,GAAG,IAAI,CAACA,KAAK,CAACiG,IAAI,UAAU;UACnCS,SAAS,EAAE,IAAI9E,IAAI,CAAC,CAAC,CAAC+E,WAAW,CAAC;QACpC;MACF,CAAC;IACH,CAAC,CAAC,OAAO3F,KAAK,EAAE;MACd,OAAO;QACLK,MAAM,EAAE,WAAW;QACnBK,OAAO,EAAE;UACPV,KAAK,EAAEA,KAAK,YAAY4F,KAAK,GAAG5F,KAAK,CAACM,OAAO,GAAG,eAAe;UAC/DoF,SAAS,EAAE,IAAI9E,IAAI,CAAC,CAAC,CAAC+E,WAAW,CAAC;QACpC;MACF,CAAC;IACH;EACF;AACF;AAACE,qBAAA,GAlXYnH,oBAAoB;AAApBA,oBAAoB,CAChBG,QAAQ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}