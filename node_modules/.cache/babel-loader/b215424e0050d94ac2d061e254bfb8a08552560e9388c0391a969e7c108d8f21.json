{"ast":null,"code":"var _DataService;\nimport axios from 'axios';\nimport { MOCK_BUYBACK_DATA } from '../config/protocols';\nimport { DatabaseService } from '../database/browserDb';\nimport { format } from 'date-fns';\nexport class DataService {\n  static getInstance() {\n    if (!DataService.instance) {\n      DataService.instance = new DataService();\n    }\n    return DataService.instance;\n  }\n  constructor() {\n    this.cache = new Map();\n    this.CACHE_DURATION = 5 * 60 * 1000;\n    // 5 minutes\n    this.dbService = void 0;\n    this.dbService = DatabaseService.getInstance();\n  }\n  isValidCache(key) {\n    const cached = this.cache.get(key);\n    return cached ? Date.now() - cached.timestamp < this.CACHE_DURATION : false;\n  }\n  async getTokenPrice(coingeckoId) {\n    const cacheKey = `price_${coingeckoId}`;\n    if (this.isValidCache(cacheKey)) {\n      return this.cache.get(cacheKey).data;\n    }\n    try {\n      var _response$data$coinge;\n      // Try to fetch from CoinGecko API\n      const response = await axios.get(`https://api.coingecko.com/api/v3/simple/price?ids=${coingeckoId}&vs_currencies=usd`, {\n        timeout: 5000\n      });\n      const price = ((_response$data$coinge = response.data[coingeckoId]) === null || _response$data$coinge === void 0 ? void 0 : _response$data$coinge.usd) || 0;\n      this.cache.set(cacheKey, {\n        data: price,\n        timestamp: Date.now()\n      });\n      return price;\n    } catch (error) {\n      console.warn(`Failed to fetch price for ${coingeckoId}:`, error);\n      // Return mock prices if API fails\n      const mockPrices = {\n        'hyperliquid': 19.3,\n        'jupiter-exchange-solana': 0.6,\n        'aave': 192.0\n      };\n      return mockPrices[coingeckoId] || 1;\n    }\n  }\n  async getBuybackData(token) {\n    const cacheKey = `buyback_${token}`;\n    if (this.isValidCache(cacheKey)) {\n      return this.cache.get(cacheKey).data;\n    }\n    try {\n      // In a real implementation, this would fetch from various APIs\n      // For now, we'll use the mock data with real price updates\n      const mockData = MOCK_BUYBACK_DATA[token];\n      if (!mockData) {\n        throw new Error(`No data available for token: ${token}`);\n      }\n\n      // Add some randomness to simulate real-time updates\n      const variance = 0.95 + Math.random() * 0.1; // Â±5% variance\n      const updatedData = {\n        ...mockData,\n        totalRepurchased: Math.floor(mockData.totalRepurchased * variance),\n        totalValueUSD: Math.floor(mockData.totalValueUSD * variance),\n        lastUpdated: new Date().toISOString().split('T')[0]\n      };\n      this.cache.set(cacheKey, {\n        data: updatedData,\n        timestamp: Date.now()\n      });\n      return updatedData;\n    } catch (error) {\n      console.error(`Failed to fetch buyback data for ${token}:`, error);\n      throw error;\n    }\n  }\n  async getAllBuybackData() {\n    try {\n      // Try to get data from database first\n      const dbData = this.dbService.getLatestBuybackData();\n      if (dbData.length > 0) {\n        // Convert database records to BuybackData format\n        const buybackData = dbData.map(record => this.convertDbRecordToBuybackData(record));\n\n        // Save new data to database (simulate real-time updates)\n        await this.saveCurrentDataToDb();\n        return buybackData;\n      } else {\n        // Fallback to fetching fresh data if no DB data\n        const tokens = ['HYPE', 'JUP', 'AAVE'];\n        const promises = tokens.map(token => this.getBuybackData(token));\n        const data = await Promise.all(promises);\n\n        // Save to database\n        await this.saveDataToDatabase(data);\n        return data;\n      }\n    } catch (error) {\n      console.error('Error getting buyback data:', error);\n      // Fallback to mock data\n      const tokens = ['HYPE', 'JUP', 'AAVE'];\n      const promises = tokens.map(token => this.getBuybackData(token));\n      return Promise.all(promises);\n    }\n  }\n  convertDbRecordToBuybackData(record) {\n    return {\n      protocol: record.protocol,\n      token: record.token,\n      totalRepurchased: record.total_repurchased,\n      totalValueUSD: record.total_value_usd,\n      circulatingSupplyPercent: record.circulating_supply_percent,\n      estimatedAnnualBuyback: record.estimated_annual_buyback,\n      feeAllocationPercent: record.fee_allocation_percent,\n      lastUpdated: record.timestamp,\n      monthlyData: [] // This would be populated separately if needed\n    };\n  }\n  async saveCurrentDataToDb() {\n    try {\n      const tokens = ['HYPE', 'JUP', 'AAVE'];\n      for (const token of tokens) {\n        const data = await this.getBuybackData(token);\n        const price = await this.getTokenPrice(this.getCoingeckoId(token));\n        const record = {\n          protocol: data.protocol,\n          token: data.token,\n          timestamp: new Date().toISOString(),\n          total_repurchased: data.totalRepurchased,\n          total_value_usd: data.totalValueUSD,\n          circulating_supply_percent: data.circulatingSupplyPercent,\n          estimated_annual_buyback: data.estimatedAnnualBuyback,\n          fee_allocation_percent: data.feeAllocationPercent,\n          price_per_token: price,\n          trading_volume_24h: this.getMockTradingVolume(token),\n          fee_generation_24h: this.getMockFeeGeneration(token)\n        };\n        this.dbService.insertBuybackRecord(record);\n\n        // Also save historical chart data\n        const dailyBuyback = data.estimatedAnnualBuyback / 365;\n        const dailyTokens = dailyBuyback / price;\n        const chartData = {\n          protocol: data.protocol,\n          timestamp: new Date().toISOString(),\n          value_usd: dailyBuyback,\n          tokens_amount: dailyTokens,\n          cumulative_value: data.totalValueUSD,\n          cumulative_tokens: data.totalRepurchased\n        };\n        this.dbService.insertHistoricalData(chartData);\n      }\n    } catch (error) {\n      console.error('Error saving data to database:', error);\n    }\n  }\n  async saveDataToDatabase(data) {\n    try {\n      for (const buybackData of data) {\n        const price = await this.getTokenPrice(this.getCoingeckoId(buybackData.token));\n        const record = {\n          protocol: buybackData.protocol,\n          token: buybackData.token,\n          timestamp: new Date().toISOString(),\n          total_repurchased: buybackData.totalRepurchased,\n          total_value_usd: buybackData.totalValueUSD,\n          circulating_supply_percent: buybackData.circulatingSupplyPercent,\n          estimated_annual_buyback: buybackData.estimatedAnnualBuyback,\n          fee_allocation_percent: buybackData.feeAllocationPercent,\n          price_per_token: price,\n          trading_volume_24h: this.getMockTradingVolume(buybackData.token),\n          fee_generation_24h: this.getMockFeeGeneration(buybackData.token)\n        };\n        this.dbService.insertBuybackRecord(record);\n      }\n    } catch (error) {\n      console.error('Error saving to database:', error);\n    }\n  }\n\n  // Helper methods\n  getCoingeckoId(token) {\n    const mapping = {\n      'HYPE': 'hyperliquid',\n      'JUP': 'jupiter-exchange-solana',\n      'AAVE': 'aave'\n    };\n    return mapping[token] || token.toLowerCase();\n  }\n  getMockTradingVolume(token) {\n    const volumes = {\n      'HYPE': 1200000000,\n      'JUP': 850000000,\n      'AAVE': 45000000\n    };\n    return volumes[token] || 0;\n  }\n  getMockFeeGeneration(token) {\n    const fees = {\n      'HYPE': 2400000,\n      'JUP': 850000,\n      'AAVE': 180000\n    };\n    return fees[token] || 0;\n  }\n\n  // New methods for chart data\n  async getHistoricalChartData(protocol, days = 30) {\n    try {\n      const data = this.dbService.getHistoricalData(protocol, days);\n      return data.map(record => ({\n        timestamp: record.timestamp,\n        date: format(new Date(record.timestamp), 'yyyy-MM-dd'),\n        protocol: record.protocol,\n        value_usd: record.value_usd,\n        tokens_amount: record.tokens_amount,\n        cumulative_value: record.cumulative_value,\n        cumulative_tokens: record.cumulative_tokens\n      }));\n    } catch (error) {\n      console.error('Error getting historical data:', error);\n      return [];\n    }\n  }\n  async getPerformanceMetrics() {\n    try {\n      return this.dbService.getPerformanceMetrics();\n    } catch (error) {\n      console.error('Error getting performance metrics:', error);\n      return [];\n    }\n  }\n  async getBuybackTrends(protocol, days = 30) {\n    try {\n      return this.dbService.getBuybackTrends(protocol, days);\n    } catch (error) {\n      console.error('Error getting buyback trends:', error);\n      return [];\n    }\n  }\n\n  // Method to fetch protocol-specific data (can be extended with real APIs)\n  async getProtocolMetrics(protocol) {\n    switch (protocol.toLowerCase()) {\n      case 'hyperliquid':\n        return this.getHyperliquidMetrics();\n      case 'jupiter':\n        return this.getJupiterMetrics();\n      case 'aave':\n        return this.getAaveMetrics();\n      default:\n        throw new Error(`Unsupported protocol: ${protocol}`);\n    }\n  }\n  async getHyperliquidMetrics() {\n    // In real implementation, this would call Hyperliquid's API\n    return {\n      tradingVolume24h: 1200000000,\n      totalValueLocked: 890000000,\n      feeGeneration24h: 2400000\n    };\n  }\n  async getJupiterMetrics() {\n    // In real implementation, this would call Jupiter's API\n    return {\n      tradingVolume24h: 850000000,\n      totalValueLocked: 320000000,\n      feeGeneration24h: 850000\n    };\n  }\n  async getAaveMetrics() {\n    // In real implementation, this would call Aave's API\n    return {\n      tradingVolume24h: 45000000,\n      totalValueLocked: 12500000000,\n      feeGeneration24h: 180000\n    };\n  }\n}\n_DataService = DataService;\nDataService.instance = void 0;","map":{"version":3,"names":["axios","MOCK_BUYBACK_DATA","DatabaseService","format","DataService","getInstance","instance","constructor","cache","Map","CACHE_DURATION","dbService","isValidCache","key","cached","get","Date","now","timestamp","getTokenPrice","coingeckoId","cacheKey","data","_response$data$coinge","response","timeout","price","usd","set","error","console","warn","mockPrices","getBuybackData","token","mockData","Error","variance","Math","random","updatedData","totalRepurchased","floor","totalValueUSD","lastUpdated","toISOString","split","getAllBuybackData","dbData","getLatestBuybackData","length","buybackData","map","record","convertDbRecordToBuybackData","saveCurrentDataToDb","tokens","promises","Promise","all","saveDataToDatabase","protocol","total_repurchased","total_value_usd","circulatingSupplyPercent","circulating_supply_percent","estimatedAnnualBuyback","estimated_annual_buyback","feeAllocationPercent","fee_allocation_percent","monthlyData","getCoingeckoId","price_per_token","trading_volume_24h","getMockTradingVolume","fee_generation_24h","getMockFeeGeneration","insertBuybackRecord","dailyBuyback","dailyTokens","chartData","value_usd","tokens_amount","cumulative_value","cumulative_tokens","insertHistoricalData","mapping","toLowerCase","volumes","fees","getHistoricalChartData","days","getHistoricalData","date","getPerformanceMetrics","getBuybackTrends","getProtocolMetrics","getHyperliquidMetrics","getJupiterMetrics","getAaveMetrics","tradingVolume24h","totalValueLocked","feeGeneration24h","_DataService"],"sources":["/Users/gherardolattanzi/treasury/src/services/dataService.ts"],"sourcesContent":["import axios from 'axios';\nimport { BuybackData } from '../types';\nimport { MOCK_BUYBACK_DATA } from '../config/protocols';\nimport { DatabaseService, BuybackRecord, HistoricalChart } from '../database/browserDb';\nimport { format } from 'date-fns';\n\nexport class DataService {\n  private static instance: DataService;\n  private cache: Map<string, { data: any; timestamp: number }> = new Map();\n  private readonly CACHE_DURATION = 5 * 60 * 1000; // 5 minutes\n  private dbService: DatabaseService;\n\n  public static getInstance(): DataService {\n    if (!DataService.instance) {\n      DataService.instance = new DataService();\n    }\n    return DataService.instance;\n  }\n\n  constructor() {\n    this.dbService = DatabaseService.getInstance();\n  }\n\n  private isValidCache(key: string): boolean {\n    const cached = this.cache.get(key);\n    return cached ? Date.now() - cached.timestamp < this.CACHE_DURATION : false;\n  }\n\n  async getTokenPrice(coingeckoId: string): Promise<number> {\n    const cacheKey = `price_${coingeckoId}`;\n    \n    if (this.isValidCache(cacheKey)) {\n      return this.cache.get(cacheKey)!.data;\n    }\n\n    try {\n      // Try to fetch from CoinGecko API\n      const response = await axios.get(\n        `https://api.coingecko.com/api/v3/simple/price?ids=${coingeckoId}&vs_currencies=usd`,\n        { timeout: 5000 }\n      );\n      \n      const price = response.data[coingeckoId]?.usd || 0;\n      this.cache.set(cacheKey, { data: price, timestamp: Date.now() });\n      return price;\n    } catch (error) {\n      console.warn(`Failed to fetch price for ${coingeckoId}:`, error);\n      // Return mock prices if API fails\n      const mockPrices: { [key: string]: number } = {\n        'hyperliquid': 19.3,\n        'jupiter-exchange-solana': 0.6,\n        'aave': 192.0\n      };\n      return mockPrices[coingeckoId] || 1;\n    }\n  }\n\n  async getBuybackData(token: string): Promise<BuybackData> {\n    const cacheKey = `buyback_${token}`;\n    \n    if (this.isValidCache(cacheKey)) {\n      return this.cache.get(cacheKey)!.data;\n    }\n\n    try {\n      // In a real implementation, this would fetch from various APIs\n      // For now, we'll use the mock data with real price updates\n      const mockData = MOCK_BUYBACK_DATA[token as keyof typeof MOCK_BUYBACK_DATA];\n      if (!mockData) {\n        throw new Error(`No data available for token: ${token}`);\n      }\n\n      // Add some randomness to simulate real-time updates\n      const variance = 0.95 + Math.random() * 0.1; // Â±5% variance\n      const updatedData: BuybackData = {\n        ...mockData,\n        totalRepurchased: Math.floor(mockData.totalRepurchased * variance),\n        totalValueUSD: Math.floor(mockData.totalValueUSD * variance),\n        lastUpdated: new Date().toISOString().split('T')[0]\n      };\n\n      this.cache.set(cacheKey, { data: updatedData, timestamp: Date.now() });\n      return updatedData;\n    } catch (error) {\n      console.error(`Failed to fetch buyback data for ${token}:`, error);\n      throw error;\n    }\n  }\n\n  async getAllBuybackData(): Promise<BuybackData[]> {\n    try {\n      // Try to get data from database first\n      const dbData = this.dbService.getLatestBuybackData();\n      \n      if (dbData.length > 0) {\n        // Convert database records to BuybackData format\n        const buybackData = dbData.map(record => this.convertDbRecordToBuybackData(record));\n        \n        // Save new data to database (simulate real-time updates)\n        await this.saveCurrentDataToDb();\n        \n        return buybackData;\n      } else {\n        // Fallback to fetching fresh data if no DB data\n        const tokens = ['HYPE', 'JUP', 'AAVE'];\n        const promises = tokens.map(token => this.getBuybackData(token));\n        const data = await Promise.all(promises);\n        \n        // Save to database\n        await this.saveDataToDatabase(data);\n        \n        return data;\n      }\n    } catch (error) {\n      console.error('Error getting buyback data:', error);\n      // Fallback to mock data\n      const tokens = ['HYPE', 'JUP', 'AAVE'];\n      const promises = tokens.map(token => this.getBuybackData(token));\n      return Promise.all(promises);\n    }\n  }\n\n  private convertDbRecordToBuybackData(record: BuybackRecord): BuybackData {\n    return {\n      protocol: record.protocol,\n      token: record.token,\n      totalRepurchased: record.total_repurchased,\n      totalValueUSD: record.total_value_usd,\n      circulatingSupplyPercent: record.circulating_supply_percent,\n      estimatedAnnualBuyback: record.estimated_annual_buyback,\n      feeAllocationPercent: record.fee_allocation_percent,\n      lastUpdated: record.timestamp,\n      monthlyData: [] // This would be populated separately if needed\n    };\n  }\n\n  private async saveCurrentDataToDb(): Promise<void> {\n    try {\n      const tokens = ['HYPE', 'JUP', 'AAVE'];\n      \n      for (const token of tokens) {\n        const data = await this.getBuybackData(token);\n        const price = await this.getTokenPrice(this.getCoingeckoId(token));\n        \n        const record: BuybackRecord = {\n          protocol: data.protocol,\n          token: data.token,\n          timestamp: new Date().toISOString(),\n          total_repurchased: data.totalRepurchased,\n          total_value_usd: data.totalValueUSD,\n          circulating_supply_percent: data.circulatingSupplyPercent,\n          estimated_annual_buyback: data.estimatedAnnualBuyback,\n          fee_allocation_percent: data.feeAllocationPercent,\n          price_per_token: price,\n          trading_volume_24h: this.getMockTradingVolume(token),\n          fee_generation_24h: this.getMockFeeGeneration(token)\n        };\n\n        this.dbService.insertBuybackRecord(record);\n\n        // Also save historical chart data\n        const dailyBuyback = data.estimatedAnnualBuyback / 365;\n        const dailyTokens = dailyBuyback / price;\n        \n        const chartData: HistoricalChart = {\n          protocol: data.protocol,\n          timestamp: new Date().toISOString(),\n          value_usd: dailyBuyback,\n          tokens_amount: dailyTokens,\n          cumulative_value: data.totalValueUSD,\n          cumulative_tokens: data.totalRepurchased\n        };\n\n        this.dbService.insertHistoricalData(chartData);\n      }\n    } catch (error) {\n      console.error('Error saving data to database:', error);\n    }\n  }\n\n  private async saveDataToDatabase(data: BuybackData[]): Promise<void> {\n    try {\n      for (const buybackData of data) {\n        const price = await this.getTokenPrice(this.getCoingeckoId(buybackData.token));\n        \n        const record: BuybackRecord = {\n          protocol: buybackData.protocol,\n          token: buybackData.token,\n          timestamp: new Date().toISOString(),\n          total_repurchased: buybackData.totalRepurchased,\n          total_value_usd: buybackData.totalValueUSD,\n          circulating_supply_percent: buybackData.circulatingSupplyPercent,\n          estimated_annual_buyback: buybackData.estimatedAnnualBuyback,\n          fee_allocation_percent: buybackData.feeAllocationPercent,\n          price_per_token: price,\n          trading_volume_24h: this.getMockTradingVolume(buybackData.token),\n          fee_generation_24h: this.getMockFeeGeneration(buybackData.token)\n        };\n\n        this.dbService.insertBuybackRecord(record);\n      }\n    } catch (error) {\n      console.error('Error saving to database:', error);\n    }\n  }\n\n  // Helper methods\n  private getCoingeckoId(token: string): string {\n    const mapping: { [key: string]: string } = {\n      'HYPE': 'hyperliquid',\n      'JUP': 'jupiter-exchange-solana',\n      'AAVE': 'aave'\n    };\n    return mapping[token] || token.toLowerCase();\n  }\n\n  private getMockTradingVolume(token: string): number {\n    const volumes: { [key: string]: number } = {\n      'HYPE': 1200000000,\n      'JUP': 850000000,\n      'AAVE': 45000000\n    };\n    return volumes[token] || 0;\n  }\n\n  private getMockFeeGeneration(token: string): number {\n    const fees: { [key: string]: number } = {\n      'HYPE': 2400000,\n      'JUP': 850000,\n      'AAVE': 180000\n    };\n    return fees[token] || 0;\n  }\n\n  // New methods for chart data\n  async getHistoricalChartData(protocol?: string, days: number = 30): Promise<any[]> {\n    try {\n      const data = this.dbService.getHistoricalData(protocol, days);\n      \n      return data.map(record => ({\n        timestamp: record.timestamp,\n        date: format(new Date(record.timestamp), 'yyyy-MM-dd'),\n        protocol: record.protocol,\n        value_usd: record.value_usd,\n        tokens_amount: record.tokens_amount,\n        cumulative_value: record.cumulative_value,\n        cumulative_tokens: record.cumulative_tokens\n      }));\n    } catch (error) {\n      console.error('Error getting historical data:', error);\n      return [];\n    }\n  }\n\n  async getPerformanceMetrics(): Promise<any[]> {\n    try {\n      return this.dbService.getPerformanceMetrics();\n    } catch (error) {\n      console.error('Error getting performance metrics:', error);\n      return [];\n    }\n  }\n\n  async getBuybackTrends(protocol: string, days: number = 30): Promise<any[]> {\n    try {\n      return this.dbService.getBuybackTrends(protocol, days);\n    } catch (error) {\n      console.error('Error getting buyback trends:', error);\n      return [];\n    }\n  }\n\n  // Method to fetch protocol-specific data (can be extended with real APIs)\n  async getProtocolMetrics(protocol: string): Promise<any> {\n    switch (protocol.toLowerCase()) {\n      case 'hyperliquid':\n        return this.getHyperliquidMetrics();\n      case 'jupiter':\n        return this.getJupiterMetrics();\n      case 'aave':\n        return this.getAaveMetrics();\n      default:\n        throw new Error(`Unsupported protocol: ${protocol}`);\n    }\n  }\n\n  private async getHyperliquidMetrics(): Promise<any> {\n    // In real implementation, this would call Hyperliquid's API\n    return {\n      tradingVolume24h: 1200000000,\n      totalValueLocked: 890000000,\n      feeGeneration24h: 2400000\n    };\n  }\n\n  private async getJupiterMetrics(): Promise<any> {\n    // In real implementation, this would call Jupiter's API\n    return {\n      tradingVolume24h: 850000000,\n      totalValueLocked: 320000000,\n      feeGeneration24h: 850000\n    };\n  }\n\n  private async getAaveMetrics(): Promise<any> {\n    // In real implementation, this would call Aave's API\n    return {\n      tradingVolume24h: 45000000,\n      totalValueLocked: 12500000000,\n      feeGeneration24h: 180000\n    };\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}