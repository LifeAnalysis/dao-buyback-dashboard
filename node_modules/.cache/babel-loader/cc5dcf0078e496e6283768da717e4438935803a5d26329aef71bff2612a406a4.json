{"ast":null,"code":"var _OptimizedDataService;/**\n * Optimized Data Service\n * Clean, modular service with proper error handling, caching, and validation\n */import axios from'axios';import{PROTOCOL_TOKENS,COINGECKO_IDS,MOCK_PRICES,API_ENDPOINTS,API_TIMEOUTS,CACHE_DURATIONS,EXPECTED_PROTOCOL_COUNT}from'../constants';import{formatDate}from'../utils/formatters';import{isValidProtocolToken,isValidPrice,isValidVolume,createError,isNetworkError,createCacheKey,isCacheExpired}from'../utils/helpers';import{DatabaseService}from'../database/browserDb';/**\n * Service configuration interface\n *//**\n * Default service configuration\n */const DEFAULT_CONFIG={baseURL:API_ENDPOINTS.COINGECKO_BASE,timeout:API_TIMEOUTS.DEFAULT,retries:3,cacheDuration:CACHE_DURATIONS.MEDIUM,enableMockData:true};/**\n * Optimized Data Service Class\n */export class OptimizedDataService{/**\n   * Singleton pattern implementation\n   */static getInstance(config){if(!OptimizedDataService.instance){OptimizedDataService.instance=new OptimizedDataService(config);}return OptimizedDataService.instance;}/**\n   * Private constructor\n   */constructor(config){this.config=void 0;this.apiClient=void 0;this.cache=new Map();this.dbService=void 0;this.config={...DEFAULT_CONFIG,...config};this.dbService=DatabaseService.getInstance();this.apiClient=this.createApiClient();}/**\n   * Create configured Axios instance\n   */createApiClient(){const client=axios.create({baseURL:this.config.baseURL,timeout:this.config.timeout,headers:{'Content-Type':'application/json','Accept':'application/json'}});// Add request interceptor for logging\nclient.interceptors.request.use(config=>{var _config$method;console.log(`üöÄ API Request: ${(_config$method=config.method)===null||_config$method===void 0?void 0:_config$method.toUpperCase()} ${config.url}`);return config;},error=>Promise.reject(this.createServiceError('REQUEST_ERROR',error)));// Add response interceptor for error handling\nclient.interceptors.response.use(response=>{console.log(`‚úÖ API Response: ${response.status} ${response.config.url}`);return response;},error=>{console.error(`‚ùå API Error: ${error.message}`);return Promise.reject(this.createServiceError('RESPONSE_ERROR',error));});return client;}/**\n   * Create standardized service error\n   */createServiceError(type,originalError){const code=isNetworkError(originalError)?'NETWORK_ERROR':'API_ERROR';const error=createError(`${type}: ${originalError.message}`,code);error.details=originalError;error.timestamp=Date.now();return error;}/**\n   * Cache management methods\n   */getCacheEntry(key){const entry=this.cache.get(key);if(!entry||isCacheExpired(entry.timestamp,this.config.cacheDuration)){this.cache.delete(key);return null;}return entry.data;}setCacheEntry(key,data){const entry={data,timestamp:Date.now(),expiresAt:Date.now()+this.config.cacheDuration};this.cache.set(key,entry);}clearCache(){this.cache.clear();}/**\n   * Validation methods\n   */validateProtocolToken(token){if(!isValidProtocolToken(token)){throw createError(`Invalid protocol token: ${token}`,'VALIDATION_ERROR');}return token;}validatePriceData(price,token){if(!isValidPrice(price)){console.warn(`Invalid price for ${token}: ${price}, using mock data`);const validToken=token;const coingeckoId=COINGECKO_IDS[validToken];return MOCK_PRICES[coingeckoId]||1;}return price;}/**\n   * API request with retry logic\n   */async apiRequest(config){let retries=arguments.length>1&&arguments[1]!==undefined?arguments[1]:this.config.retries;try{const response=await this.apiClient.request(config);return response.data;}catch(error){if(retries>0&&isNetworkError(error)){console.warn(`Retrying API request... ${retries} attempts remaining`);await new Promise(resolve=>setTimeout(resolve,1000));return this.apiRequest(config,retries-1);}throw error;}}/**\n   * Get token price from CoinGecko API\n   */async getTokenPrice(token){const validToken=this.validateProtocolToken(token);const coingeckoId=COINGECKO_IDS[validToken];const cacheKey=createCacheKey('price',coingeckoId);// Check cache first\nconst cachedPrice=this.getCacheEntry(cacheKey);if(cachedPrice!==null){return cachedPrice;}try{var _response$coingeckoId;const response=await this.apiRequest({url:`/simple/price`,params:{ids:coingeckoId,vs_currencies:'usd'}});const price=(_response$coingeckoId=response[coingeckoId])===null||_response$coingeckoId===void 0?void 0:_response$coingeckoId.usd;if(typeof price!=='number'){throw createError(`Invalid price response for ${token}`,'API_ERROR');}const validatedPrice=this.validatePriceData(price,token);this.setCacheEntry(cacheKey,validatedPrice);return validatedPrice;}catch(error){console.warn(`Failed to fetch price for ${token}, using mock data:`,error);return MOCK_PRICES[coingeckoId]||1;}}/**\n   * Get buyback data for a specific protocol\n   */async getBuybackData(token){const validToken=this.validateProtocolToken(token);const cacheKey=createCacheKey('buyback',validToken);// Check cache first\nconst cachedData=this.getCacheEntry(cacheKey);if(cachedData){return cachedData;}try{// Get current price (for future use when integrating real price data)\nawait this.getTokenPrice(validToken);// Get mock buyback data from config\nconst mockData=await import('../config/protocols');const protocolData=mockData.MOCK_BUYBACK_DATA[validToken];if(!protocolData){throw createError(`No mock data available for ${validToken}`,'VALIDATION_ERROR');}// Create buyback data with real price\nconst buybackData={...protocolData,lastUpdated:formatDate(new Date())};// Validate the data\nif(!isValidVolume(buybackData.totalValueUSD)){console.warn(`Invalid volume data for ${validToken}`);}this.setCacheEntry(cacheKey,buybackData);return buybackData;}catch(error){console.error(`Failed to get buyback data for ${validToken}:`,error);throw this.createServiceError('BUYBACK_DATA_ERROR',error);}}/**\n   * Get all buyback data for all protocols\n   */async getAllBuybackData(){const cacheKey='all_buyback_data';// Check cache first\nconst cachedData=this.getCacheEntry(cacheKey);if(cachedData&&cachedData.length===EXPECTED_PROTOCOL_COUNT){return cachedData;}try{// Try to get data from database first\nconst dbData=this.dbService.getLatestBuybackData();if(dbData.length>=EXPECTED_PROTOCOL_COUNT){const buybackData=dbData.map(record=>this.convertDbRecordToBuybackData(record));// Update database with fresh data\nawait this.saveCurrentDataToDb();this.setCacheEntry(cacheKey,buybackData);return buybackData;}// Fallback: Fetch fresh data for all protocols\nconsole.log('Fetching fresh data for all protocols...');const dataPromises=PROTOCOL_TOKENS.map(token=>this.getBuybackData(token));const allData=await Promise.all(dataPromises);// Save to database\nawait this.saveDataToDatabase(allData);this.setCacheEntry(cacheKey,allData);return allData;}catch(error){console.error('Error getting all buyback data:',error);// Final fallback: Return mock data for all protocols\nconsole.warn('Using fallback mock data for all protocols');const fallbackPromises=PROTOCOL_TOKENS.map(token=>this.getBuybackData(token));return Promise.all(fallbackPromises);}}/**\n   * Get historical chart data\n   */async getHistoricalChartData(protocol){let days=arguments.length>1&&arguments[1]!==undefined?arguments[1]:30;const cacheKey=createCacheKey('historical',protocol||'all',days);// Check cache first\nconst cachedData=this.getCacheEntry(cacheKey);if(cachedData){return cachedData;}try{const historicalData=this.dbService.getHistoricalData(protocol,days);this.setCacheEntry(cacheKey,historicalData);return historicalData;}catch(error){console.error('Error getting historical data:',error);return[];}}/**\n   * Database operations\n   */convertDbRecordToBuybackData(record){return{protocol:record.protocol,token:record.token,totalRepurchased:record.total_repurchased,totalValueUSD:record.total_value_usd,circulatingSupplyPercent:record.circulating_supply_percent,estimatedAnnualBuyback:record.estimated_annual_buyback,feeAllocationPercent:record.fee_allocation_percent,lastUpdated:formatDate(new Date(record.timestamp))};}async saveDataToDatabase(data){try{// This would integrate with the database service\nconsole.log('Saving data to database:',data.length,'records');// Implementation would go here\n}catch(error){console.error('Error saving to database:',error);}}async saveCurrentDataToDb(){try{// Simulate saving current data\nconsole.log('Saving current data to database');// Implementation would go here\n}catch(error){console.error('Error saving current data:',error);}}/**\n   * Utility methods\n   */getCacheStats(){return{size:this.cache.size,entries:Array.from(this.cache.keys())};}clearAllCache(){this.clearCache();console.log('üóëÔ∏è All cache cleared');}async healthCheck(){try{// Test API connectivity\nawait this.apiRequest({url:'/ping',timeout:3000});// Test database connectivity\nconst dbData=this.dbService.getLatestBuybackData();return{status:'healthy',details:{api:'connected',database:`${dbData.length} records`,cache:`${this.cache.size} entries`,lastCheck:new Date().toISOString()}};}catch(error){return{status:'unhealthy',details:{error:error instanceof Error?error.message:'Unknown error',lastCheck:new Date().toISOString()}};}}}_OptimizedDataService=OptimizedDataService;OptimizedDataService.instance=void 0;","map":{"version":3,"names":["axios","PROTOCOL_TOKENS","COINGECKO_IDS","MOCK_PRICES","API_ENDPOINTS","API_TIMEOUTS","CACHE_DURATIONS","EXPECTED_PROTOCOL_COUNT","formatDate","isValidProtocolToken","isValidPrice","isValidVolume","createError","isNetworkError","createCacheKey","isCacheExpired","DatabaseService","DEFAULT_CONFIG","baseURL","COINGECKO_BASE","timeout","DEFAULT","retries","cacheDuration","MEDIUM","enableMockData","OptimizedDataService","getInstance","config","instance","constructor","apiClient","cache","Map","dbService","createApiClient","client","create","headers","interceptors","request","use","_config$method","console","log","method","toUpperCase","url","error","Promise","reject","createServiceError","response","status","message","type","originalError","code","details","timestamp","Date","now","getCacheEntry","key","entry","get","delete","data","setCacheEntry","expiresAt","set","clearCache","clear","validateProtocolToken","token","validatePriceData","price","warn","validToken","coingeckoId","apiRequest","arguments","length","undefined","resolve","setTimeout","getTokenPrice","cacheKey","cachedPrice","_response$coingeckoId","params","ids","vs_currencies","usd","validatedPrice","getBuybackData","cachedData","mockData","protocolData","MOCK_BUYBACK_DATA","buybackData","lastUpdated","totalValueUSD","getAllBuybackData","dbData","getLatestBuybackData","map","record","convertDbRecordToBuybackData","saveCurrentDataToDb","dataPromises","allData","all","saveDataToDatabase","fallbackPromises","getHistoricalChartData","protocol","days","historicalData","getHistoricalData","totalRepurchased","total_repurchased","total_value_usd","circulatingSupplyPercent","circulating_supply_percent","estimatedAnnualBuyback","estimated_annual_buyback","feeAllocationPercent","fee_allocation_percent","getCacheStats","size","entries","Array","from","keys","clearAllCache","healthCheck","api","database","lastCheck","toISOString","Error","_OptimizedDataService"],"sources":["/Users/gherardolattanzi/treasury/src/services/optimizedDataService.ts"],"sourcesContent":["/**\n * Optimized Data Service\n * Clean, modular service with proper error handling, caching, and validation\n */\n\nimport axios, { AxiosInstance, AxiosRequestConfig } from 'axios';\nimport { \n  PROTOCOL_TOKENS, \n  COINGECKO_IDS, \n  MOCK_PRICES, \n  API_ENDPOINTS,\n  API_TIMEOUTS,\n  CACHE_DURATIONS,\n  EXPECTED_PROTOCOL_COUNT \n} from '../constants';\nimport { \n  formatDate\n} from '../utils/formatters';\nimport {\n  isValidProtocolToken,\n  isValidPrice,\n  isValidVolume,\n  createError,\n  isNetworkError,\n  createCacheKey,\n  isCacheExpired\n} from '../utils/helpers';\nimport { DatabaseService } from '../database/browserDb';\nimport type { \n  BuybackData, \n  ProtocolToken, \n  CacheEntry, \n  AppError,\n  ErrorCode \n} from '../types';\n\n/**\n * Service configuration interface\n */\ninterface ServiceConfig {\n  baseURL?: string;\n  timeout?: number;\n  retries?: number;\n  cacheDuration?: number;\n  enableMockData?: boolean;\n}\n\n/**\n * Default service configuration\n */\nconst DEFAULT_CONFIG: Required<ServiceConfig> = {\n  baseURL: API_ENDPOINTS.COINGECKO_BASE,\n  timeout: API_TIMEOUTS.DEFAULT,\n  retries: 3,\n  cacheDuration: CACHE_DURATIONS.MEDIUM,\n  enableMockData: true,\n};\n\n/**\n * Optimized Data Service Class\n */\nexport class OptimizedDataService {\n  private static instance: OptimizedDataService;\n  private readonly config: Required<ServiceConfig>;\n  private readonly apiClient: AxiosInstance;\n  private readonly cache = new Map<string, CacheEntry>();\n  private readonly dbService: DatabaseService;\n\n  /**\n   * Singleton pattern implementation\n   */\n  public static getInstance(config?: ServiceConfig): OptimizedDataService {\n    if (!OptimizedDataService.instance) {\n      OptimizedDataService.instance = new OptimizedDataService(config);\n    }\n    return OptimizedDataService.instance;\n  }\n\n  /**\n   * Private constructor\n   */\n  private constructor(config?: ServiceConfig) {\n    this.config = { ...DEFAULT_CONFIG, ...config };\n    this.dbService = DatabaseService.getInstance();\n    this.apiClient = this.createApiClient();\n  }\n\n  /**\n   * Create configured Axios instance\n   */\n  private createApiClient(): AxiosInstance {\n    const client = axios.create({\n      baseURL: this.config.baseURL,\n      timeout: this.config.timeout,\n      headers: {\n        'Content-Type': 'application/json',\n        'Accept': 'application/json',\n      },\n    });\n\n    // Add request interceptor for logging\n    client.interceptors.request.use(\n      (config) => {\n        console.log(`üöÄ API Request: ${config.method?.toUpperCase()} ${config.url}`);\n        return config;\n      },\n      (error) => Promise.reject(this.createServiceError('REQUEST_ERROR', error))\n    );\n\n    // Add response interceptor for error handling\n    client.interceptors.response.use(\n      (response) => {\n        console.log(`‚úÖ API Response: ${response.status} ${response.config.url}`);\n        return response;\n      },\n      (error) => {\n        console.error(`‚ùå API Error: ${error.message}`);\n        return Promise.reject(this.createServiceError('RESPONSE_ERROR', error));\n      }\n    );\n\n    return client;\n  }\n\n  /**\n   * Create standardized service error\n   */\n  private createServiceError(type: string, originalError: any): AppError {\n    const code: ErrorCode = isNetworkError(originalError) ? 'NETWORK_ERROR' : 'API_ERROR';\n    const error = createError(`${type}: ${originalError.message}`, code) as AppError;\n    error.details = originalError;\n    error.timestamp = Date.now();\n    return error;\n  }\n\n  /**\n   * Cache management methods\n   */\n  private getCacheEntry<T>(key: string): T | null {\n    const entry = this.cache.get(key);\n    if (!entry || isCacheExpired(entry.timestamp, this.config.cacheDuration)) {\n      this.cache.delete(key);\n      return null;\n    }\n    return entry.data;\n  }\n\n  private setCacheEntry<T>(key: string, data: T): void {\n    const entry: CacheEntry<T> = {\n      data,\n      timestamp: Date.now(),\n      expiresAt: Date.now() + this.config.cacheDuration,\n    };\n    this.cache.set(key, entry);\n  }\n\n  private clearCache(): void {\n    this.cache.clear();\n  }\n\n  /**\n   * Validation methods\n   */\n  private validateProtocolToken(token: string): ProtocolToken {\n    if (!isValidProtocolToken(token)) {\n      throw createError(`Invalid protocol token: ${token}`, 'VALIDATION_ERROR');\n    }\n    return token as ProtocolToken;\n  }\n\n  private validatePriceData(price: number, token: string): number {\n    if (!isValidPrice(price)) {\n      console.warn(`Invalid price for ${token}: ${price}, using mock data`);\n      const validToken = token as ProtocolToken;\n      const coingeckoId = COINGECKO_IDS[validToken];\n      return MOCK_PRICES[coingeckoId as keyof typeof MOCK_PRICES] || 1;\n    }\n    return price;\n  }\n\n  /**\n   * API request with retry logic\n   */\n  private async apiRequest<T>(\n    config: AxiosRequestConfig,\n    retries: number = this.config.retries\n  ): Promise<T> {\n    try {\n      const response = await this.apiClient.request<T>(config);\n      return response.data;\n    } catch (error) {\n      if (retries > 0 && isNetworkError(error)) {\n        console.warn(`Retrying API request... ${retries} attempts remaining`);\n        await new Promise(resolve => setTimeout(resolve, 1000));\n        return this.apiRequest<T>(config, retries - 1);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Get token price from CoinGecko API\n   */\n  async getTokenPrice(token: ProtocolToken): Promise<number> {\n    const validToken = this.validateProtocolToken(token);\n    const coingeckoId = COINGECKO_IDS[validToken];\n    const cacheKey = createCacheKey('price', coingeckoId);\n\n    // Check cache first\n    const cachedPrice = this.getCacheEntry<number>(cacheKey);\n    if (cachedPrice !== null) {\n      return cachedPrice;\n    }\n\n    try {\n      const response = await this.apiRequest<Record<string, { usd: number }>>({\n        url: `/simple/price`,\n        params: {\n          ids: coingeckoId,\n          vs_currencies: 'usd',\n        },\n      });\n\n      const price = response[coingeckoId]?.usd;\n      if (typeof price !== 'number') {\n        throw createError(`Invalid price response for ${token}`, 'API_ERROR');\n      }\n\n      const validatedPrice = this.validatePriceData(price, token);\n      this.setCacheEntry(cacheKey, validatedPrice);\n      return validatedPrice;\n\n    } catch (error) {\n      console.warn(`Failed to fetch price for ${token}, using mock data:`, error);\n      return MOCK_PRICES[coingeckoId as keyof typeof MOCK_PRICES] || 1;\n    }\n  }\n\n  /**\n   * Get buyback data for a specific protocol\n   */\n  async getBuybackData(token: ProtocolToken): Promise<BuybackData> {\n    const validToken = this.validateProtocolToken(token);\n    const cacheKey = createCacheKey('buyback', validToken);\n\n    // Check cache first\n    const cachedData = this.getCacheEntry<BuybackData>(cacheKey);\n    if (cachedData) {\n      return cachedData;\n    }\n\n    try {\n      // Get current price (for future use when integrating real price data)\n      await this.getTokenPrice(validToken);\n      \n      // Get mock buyback data from config\n      const mockData = await import('../config/protocols');\n      const protocolData = (mockData.MOCK_BUYBACK_DATA as any)[validToken];\n      \n      if (!protocolData) {\n        throw createError(`No mock data available for ${validToken}`, 'VALIDATION_ERROR');\n      }\n\n      // Create buyback data with real price\n      const buybackData: BuybackData = {\n        ...protocolData,\n        lastUpdated: formatDate(new Date()),\n      };\n\n      // Validate the data\n      if (!isValidVolume(buybackData.totalValueUSD)) {\n        console.warn(`Invalid volume data for ${validToken}`);\n      }\n\n      this.setCacheEntry(cacheKey, buybackData);\n      return buybackData;\n\n    } catch (error) {\n      console.error(`Failed to get buyback data for ${validToken}:`, error);\n      throw this.createServiceError('BUYBACK_DATA_ERROR', error);\n    }\n  }\n\n  /**\n   * Get all buyback data for all protocols\n   */\n  async getAllBuybackData(): Promise<BuybackData[]> {\n    const cacheKey = 'all_buyback_data';\n\n    // Check cache first\n    const cachedData = this.getCacheEntry<BuybackData[]>(cacheKey);\n    if (cachedData && cachedData.length === EXPECTED_PROTOCOL_COUNT) {\n      return cachedData;\n    }\n\n    try {\n      // Try to get data from database first\n      const dbData = this.dbService.getLatestBuybackData();\n      \n      if (dbData.length >= EXPECTED_PROTOCOL_COUNT) {\n        const buybackData = dbData.map(record => this.convertDbRecordToBuybackData(record));\n        \n        // Update database with fresh data\n        await this.saveCurrentDataToDb();\n        \n        this.setCacheEntry(cacheKey, buybackData);\n        return buybackData;\n      }\n\n      // Fallback: Fetch fresh data for all protocols\n      console.log('Fetching fresh data for all protocols...');\n      const dataPromises = PROTOCOL_TOKENS.map(token => this.getBuybackData(token));\n      const allData = await Promise.all(dataPromises);\n\n      // Save to database\n      await this.saveDataToDatabase(allData);\n      \n      this.setCacheEntry(cacheKey, allData);\n      return allData;\n\n    } catch (error) {\n      console.error('Error getting all buyback data:', error);\n      \n      // Final fallback: Return mock data for all protocols\n      console.warn('Using fallback mock data for all protocols');\n      const fallbackPromises = PROTOCOL_TOKENS.map(token => this.getBuybackData(token));\n      return Promise.all(fallbackPromises);\n    }\n  }\n\n  /**\n   * Get historical chart data\n   */\n  async getHistoricalChartData(protocol?: string, days: number = 30): Promise<any[]> {\n    const cacheKey = createCacheKey('historical', protocol || 'all', days);\n\n    // Check cache first\n    const cachedData = this.getCacheEntry<any[]>(cacheKey);\n    if (cachedData) {\n      return cachedData;\n    }\n\n    try {\n      const historicalData = this.dbService.getHistoricalData(protocol, days);\n      this.setCacheEntry(cacheKey, historicalData);\n      return historicalData;\n\n    } catch (error) {\n      console.error('Error getting historical data:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Database operations\n   */\n  private convertDbRecordToBuybackData(record: any): BuybackData {\n    return {\n      protocol: record.protocol,\n      token: record.token,\n      totalRepurchased: record.total_repurchased,\n      totalValueUSD: record.total_value_usd,\n      circulatingSupplyPercent: record.circulating_supply_percent,\n      estimatedAnnualBuyback: record.estimated_annual_buyback,\n      feeAllocationPercent: record.fee_allocation_percent,\n      lastUpdated: formatDate(new Date(record.timestamp)),\n    };\n  }\n\n  private async saveDataToDatabase(data: BuybackData[]): Promise<void> {\n    try {\n      // This would integrate with the database service\n      console.log('Saving data to database:', data.length, 'records');\n      // Implementation would go here\n    } catch (error) {\n      console.error('Error saving to database:', error);\n    }\n  }\n\n  private async saveCurrentDataToDb(): Promise<void> {\n    try {\n      // Simulate saving current data\n      console.log('Saving current data to database');\n      // Implementation would go here\n    } catch (error) {\n      console.error('Error saving current data:', error);\n    }\n  }\n\n  /**\n   * Utility methods\n   */\n  public getCacheStats(): { size: number; entries: string[] } {\n    return {\n      size: this.cache.size,\n      entries: Array.from(this.cache.keys()),\n    };\n  }\n\n  public clearAllCache(): void {\n    this.clearCache();\n    console.log('üóëÔ∏è All cache cleared');\n  }\n\n  public async healthCheck(): Promise<{ status: 'healthy' | 'degraded' | 'unhealthy'; details: any }> {\n    try {\n      // Test API connectivity\n      await this.apiRequest({ url: '/ping', timeout: 3000 });\n      \n      // Test database connectivity\n      const dbData = this.dbService.getLatestBuybackData();\n      \n      return {\n        status: 'healthy',\n        details: {\n          api: 'connected',\n          database: `${dbData.length} records`,\n          cache: `${this.cache.size} entries`,\n          lastCheck: new Date().toISOString(),\n        },\n      };\n    } catch (error) {\n      return {\n        status: 'unhealthy',\n        details: {\n          error: error instanceof Error ? error.message : 'Unknown error',\n          lastCheck: new Date().toISOString(),\n        },\n      };\n    }\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}